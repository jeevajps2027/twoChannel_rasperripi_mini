{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="{% static 'fontawesome-free-6.7.2-web/css/all.min.css' %}">
    <script src="{% static 'jquery-jquery-f79d5f1/dist/jquery.min.js' %}"></script>


   
    <title>MASTERING</title>

 
    <link rel="stylesheet" href="{% static 'css/master_v.css'%}">
  
</head>

<style>


.container-4 {
    height: 65%;
    width: 100%;
    border: 1px solid black;
    background-color: bisque;

    display: flex;
    flex-direction: column; /* <-- Important */
}

.container-5{
    height: 10%;
    width: 100%;
    display: flex;
    border: 1px solid black;
}

.probe-container {
   overflow-y: auto;
   display: flex;
   align-items: center;
   gap: 5px; /* Add space between the elements */
}

.container_4_1 {
    height: 100%;
    width: 100%;
    display: flex;
    border: 1px solid black;
    background-color: bisque;
}



input[type="radio"] {
    transform: scale(1.2); /* Adjust the scale value to increase size */
    margin-top:10px;
    
}


.sub_container_4 {
    height: 100%;
    width: 50%;
    border: 1px solid black;
    display: flex;
    flex-direction: column;
    align-items: center;
    box-sizing: border-box;
    padding: 0; /* Remove padding to allow full use of height */
}

/* Top Input Box */
.input-box {
    width: 100%;
    height: 10%;
    box-sizing: border-box;
    text-align: center;
    font-weight: bold;
    font-size: 2.2vw;
    margin: 0; /* Remove margin for perfect fit */
}

/* Radio button – optional placement fix */
.selected_radio {
    margin: 5px 0;
}

.grid-container {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 2px; /* minimal gap between items */
    width: 100%;
    height: 40%; /* significantly compressed height */
    padding: 0;
    box-sizing: border-box;
}

.item {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    border: 1px solid black;
    background-color: rgb(228, 194, 244);
    padding: 1px;
    box-sizing: border-box;
    width: 95%;
    margin-left: 2%;
}

/* Label inside grid item */
.item-label {
    font-size: 2vw; /* very small font */
    font-weight: bold;
    margin: 1px 0;
    text-align: center;
   margin-bottom: 1vh;
}

/* Input box inside grid item */
.input-box1 {
    width: 90%;
    height: 7vw; /* very small height */
    font-size: 4vw; /* small readable font */
    text-align: center;
    padding: 0;
    margin: 0;
    font-weight: bold;
    box-sizing: border-box;
}


/* Center Input Box */
.center-box {
    width: 100%;
    height: 20%; /* Allocate remaining height */
    font-weight: bold;
    font-size: 6vw;
    text-align: center;
    box-sizing: border-box;
}








#customAlert {
    display: none;
    position: fixed;
    top: 50vh;
    left: 50vw;
    transform: translate(-50%, -50%);

    width: 50vw;
    height: 30vh;

    background-color: yellow;
    color: black;
    border: 0.5vh solid black;
    border-radius: 2vh;
   

    text-align: center;
    font-size: 2.5vw;
    font-weight: bold;

    z-index: 1000;
    box-sizing: border-box;
}


#customAlertCloseBtn {
    font-size: 2.5vw;
    padding: 1vh 3vh;
    border: none;
    background-color: red;
    color: white;
    border-radius: 1vh;
    cursor: pointer;
    height: 8vh;
    width: 20vw;
    font-weight: bold;
    margin-top: 3vh;
}




input[type="radio"] {
    transform: scale(2.5); /* Adjust the scale value to increase size */
    
}




</style>


<body>
    <div class="container_1">
        <div class="container_1_1">
            <input type="text" id="clock-box" readonly>
            <input type="text" id="message">
            <button type="button" id="close_btn">
                <i class="fas fa-times" id="close_icon"></i>
            </button>
        </div>


        <div class="container_2">
            <div class="sub_container_2">
                <label for="partModel">PART MODEL:</label>
                <input type="text" id="partModel" value="{{ part_name }}" readonly>
            </div>
            <div class="sub_container_2">
                <label for="all_parameter" style="margin-top: 2%;">
                    ALL CHANNEL :
                    <input type="radio" name="radio_selection"  id="all_parameter">
                </label>
                
                <label for="parameterwise"  style="margin-top: 2%;">
                    CHANNELWISE :
                    <input type="radio" name="radio_selection"  id="parameterwise" >
                </label>
            </div>
            <div class="sub_container_2">
                <label for="mastering" >MASTERING GROUP:</label>
                <select id="mastering" class="mastering_no" name="mastering">
                    <script>
                        for (var i = 1; i <= 2; i++) {
                            document.write('<option value="' + i + '">' + i + '</option>');
                        }
                    </script>
                </select>
            </div>
            
            <div class="sub_container_2">
                <button id="lowMasterBtn" type="button">LOW MASTERING</button>
                <button id="highMasterBtn" type="button">HIGH MASTERING</button>
                <button id="singleMasterBtn" type="button" style="display: none;">SINGLE MASTERING</button>
            </div>
        </div>
        <div class="container_3">
            <input type="text" id="pre">
        </div>
    </div>













    <div class="container-4">
        <div id="customAlert">
            <div id="customAlertMessage">⚠️ This is a centered alert!</div>
            <button id="customAlertCloseBtn">OK</button>
        </div>
        

        <div class="container_4_1">

        <div class="sub_container_4" id="cal_container1">
            <!-- Top Input Box -->
            <input type="text" id="para_name1" value="CHANNEL - 1" class="input-box" readonly/>
            <div style="display: flex; justify-content: center; align-items: center; height: 5%;">
                <input type="radio" class="selected_radio" id="selected_radio1">
            </div>
            
        
           
            <div class="grid-container">
                
                <div class="item">       
                    <label class="item-label">LOW MASTER</label>
                    <input type="text" id="low_master1" class="input-box1" readonly />
                </div>
                <div class="item">
                    <label class="item-label">LOW RAW COUNT</label>
                    <input type="text" id="low_raw_count1" class="input-box1" readonly />
                </div>
                <div class="item">
                    <label class="item-label">HIGH MASTER</label>
                    <input type="text" id="high_master1" class="input-box1" readonly/>
                </div>
                <div class="item">
                    <label class="item-label">HIGH RAW COUNT</label>
                    <input type="text" id="high_raw_count1" class="input-box1"readonly />
                </div>
            </div>
        
            <input type="text" id="center_input1" class="input-box center-box" readonly />
        </div>
        
        
        <div class="sub_container_4" id="cal_container2">
            <input type="text" id="para_name2" value="CHANNEL - 2" class="input-box" readonly/>

            <div style="display: flex; justify-content: center; align-items: center; height: 5%;">
            <input type="radio" class="selected_radio" id="selected_radio2">
            </div>
           
            <div class="grid-container">
                <div class="item">
                    <label class="item-label">LOW MASTER</label>
                    <input type="text" id="low_master2" class="input-box1"readonly />
                </div>
                <div class="item">
                    <label class="item-label">LOW RAW COUNT</label>
                    <input type="text" id="low_raw_count2" class="input-box1" readonly/>
                </div>
                <div class="item">
                    <label class="item-label">HIGH MASTER</label>
                    <input type="text" id="high_master2" class="input-box1" readonly/>
                </div>
                <div class="item">
                    <label class="item-label">HIGH RAW COUNT</label>
                    <input type="text" id="high_raw_count2" class="input-box1" readonly/>
                </div>
            </div>
        
            <input type="text" id="center_input2" class="input-box center-box"  readonly/>
        </div>
        <!-- <div class="sub_container_4" id="cal_container3">
            <input type="text" id="para_name3" value="CHANNEL - 3" class="input-box" readonly />

            <div style="display: flex; justify-content: center; align-items: center; height: 5%;">
            <input type="radio" class="selected_radio" id="selected_radio3">
            </div>
           
            <div class="grid-container">
                <div class="item">
                    <label class="item-label">LOW MASTER</label>
                    <input type="text" id="low_master3" class="input-box1" readonly/>
                </div>
                <div class="item">
                    <label class="item-label">LOW RAW COUNT</label>
                    <input type="text" id="low_raw_count3" class="input-box1" readonly/>
                </div>
                <div class="item">
                    <label class="item-label">HIGH MASTER</label>
                    <input type="text" id="high_master3" class="input-box1" readonly/>
                </div>
                <div class="item">
                    <label class="item-label">HIGH RAW COUNT</label>
                    <input type="text" id="high_raw_count3" class="input-box1" readonly/>
                </div>
            </div>
        
            <input type="text" id="center_input3" class="input-box center-box" readonly/>
        </div>
        <div class="sub_container_4" id="cal_container4">
            <input type="text" id="para_name4" value="CHANNEL - 4" class="input-box" readonly/>

            <div style="display: flex; justify-content: center; align-items: center; height: 5%;">
            <input type="radio" class="selected_radio" id="selected_radio4">
            </div>
           
            <div class="grid-container">
                <div class="item">
                    <label class="item-label">LOW MASTER</label>
                    <input type="text" id="low_master4" class="input-box1" readonly/>
                </div>
                <div class="item">
                    <label class="item-label">LOW RAW COUNT</label>
                    <input type="text" id="low_raw_count4" class="input-box1" readonly/>
                </div>
                <div class="item">
                    <label class="item-label">HIGH MASTER</label>
                    <input type="text" id="high_master4" class="input-box1" readonly/>
                </div>
                <div class="item">
                    <label class="item-label">HIGH RAW COUNT</label>
                    <input type="text" id="high_raw_count4" class="input-box1" readonly/>
                </div>
            </div>
        
            <input type="text" id="center_input4" class="input-box center-box" readonly />
        </div> -->
        </div>







    
    </div>
  











    <div class="container-5">
        <div class="probe-container" >
            <p>P1:</p><textarea id="probe-A"></textarea>
            <p>P2:</p><textarea id="probe-B"></textarea>
            <p>P3:</p><textarea id="probe-C"></textarea>
            <p>P4:</p><textarea id="probe-D"></textarea>

            <p>P5:</p><textarea id="probe-E"></textarea>
            <p>P6:</p><textarea id="probe-F"></textarea>
            <p>P7:</p><textarea id="probe-G"></textarea>
            <p>P8:</p><textarea id="probe-H"></textarea>

            <p>P9:</p><textarea id="probe-I"></textarea>
            <p>P10:</p><textarea id="probe-J"></textarea>
            <p>P11:</p><textarea id="probe-K"></textarea>
           
        </div>
        <div class="container_5_1">
            <button id="measureBtn" type="button"><b>Measurement<br>F1</b></button>
        </div>
    

    </div>
    <input type="hidden" name="csrfmiddlewaretoken" value="{{ csrf_token }}">


    

    <script>

        const lowBtn = document.getElementById("lowMasterBtn");
        const highBtn = document.getElementById("highMasterBtn");
        
        // Initial state: Low is big, High is small
        lowBtn.classList.add("big-btn");
        highBtn.classList.add("small-btn");
        lowBtn.focus();
        
        function toggleSize(activeBtn, inactiveBtn) {
            activeBtn.classList.add("big-btn");
            activeBtn.classList.remove("small-btn");
        
            inactiveBtn.classList.add("small-btn");
            inactiveBtn.classList.remove("big-btn");
        
            activeBtn.focus(); // Optional
        }
        
        // Reverse: If you click lowBtn, make highBtn big
        lowBtn.addEventListener("click", () => toggleSize(highBtn, lowBtn));
        highBtn.addEventListener("click", () => toggleSize(lowBtn, highBtn));
        
        
        
        
        
        
        
            document.addEventListener("DOMContentLoaded", function () {
            const inputs = document.querySelectorAll("input");
            inputs.forEach(input => input.setAttribute("autocomplete", "off"));
        });
        document.addEventListener('keydown', function(event) {
                // Check for specific function keys
                switch (event.key) {
                    case 'F1':
                        event.preventDefault(); // Prevent default action
                        document.getElementById('measureBtn').click(); // Trigger Add New button
                        break;
                       
                }
            });
        
        document.addEventListener("DOMContentLoaded", () => {
                    const redirectToMeasurement = () => {
                        // Redirect to the measurement page
                        window.location.href = "/measurement/";
                    };
        
                    // Attach click event listeners to both buttons
                    document.getElementById("close_btn").addEventListener("click", redirectToMeasurement);
                    document.getElementById("measureBtn").addEventListener("click", redirectToMeasurement);
                });
        
            function updateClock() {
            // Get the current date and time
            var currentDate = new Date();
            var hours = currentDate.getHours();
            var minutes = currentDate.getMinutes();
            var seconds = currentDate.getSeconds();
            var ampm = hours >= 12 ? 'PM' : 'AM';
        
            // Format the hours, minutes, and seconds
            hours = hours % 12;
            hours = hours ? hours : 12; // Handle midnight (0 hours)
            minutes = minutes < 10 ? '0' + minutes : minutes;
            seconds = seconds < 10 ? '0' + seconds : seconds;
        
            // Create the time string
            var currentTime = hours + ':' + minutes + ':' + seconds + ' ' + ampm;
        
            // Get the date components
            var day = currentDate.getDate();
            var month = currentDate.getMonth() + 1; // Month is zero-based
            var year = currentDate.getFullYear();
        
            // Create the date string
            var currentDateFormatted = day + '/' + month + '/' + year;
        
            // Set the value of the input box
            document.getElementById("clock-box").value = currentDateFormatted + ' ' + currentTime;
        
            // Call this function again after 1 second
            setTimeout(updateClock, 1000);
        }
        
        // Call the function to initially display the clock
        updateClock();
        
        
        ///////////////////////////////////
        // these is the function to display the radiobuttons based on this selected :
        window.addEventListener('load', function () {
        
            fetchAndDisplayValues();
        
        setTimeout(function () {
            document.getElementById('all_parameter').click();
            hideRadioButtons(); // Hide the radio buttons initially
            const preInput = document.getElementById('pre');
            preInput.value = "ALL CHANNEL IS SELECTED , DO MASTERING";
        }, 200);
        
        const parameterwiseRadio = document.getElementById('parameterwise');
        const allParameterRadio = document.getElementById('all_parameter');
        const selectedRadios = document.querySelectorAll('.selected_radio');
        
        // Hide radio buttons initially
        hideRadioButtons();
        
        // Event listener for "Parameterwise" selection
        parameterwiseRadio.addEventListener('change', function () {
            if (this.checked) {
                showRadioButtons();
                const preInput = document.getElementById('pre');
            preInput.value = "CHANNELWISE IS SELECTED ,DO MASTERING";
            
            }
        });
        
        // Event listener for "All Parameters" selection
        allParameterRadio.addEventListener('change', function () {
            if (this.checked) {
                hideRadioButtons();
        
                // Clear all selected radios
                const selectedRadios = document.querySelectorAll('.selected_radio');
                selectedRadios.forEach(radio => {
                    radio.checked = false;
                });
        
                // Remove all container highlights
                document.querySelectorAll('.sub_container_4').forEach(container => {
                    container.style.backgroundColor = "";
                });
        
                
                const preInput = document.getElementById('pre');
            preInput.value = "ALL CHANNELS IS SELECTED , DO MASTERING";
        
            const selectedValue = logSelectedValue();
            fetchAndDisplayValues(selectedValue);
         
            }
        });
        
        // Track the previously selected radio button
        let previousSelectedRadio = null;
        
        selectedRadios.forEach((radio) => {
            radio.addEventListener('change', function () {
                if (this.checked) {
                    console.log(`🔘 Selected Radio Button: ${this.id}`);
        
                    // Remove background color from all containers first
                    document.querySelectorAll('.sub_container_4').forEach(container => {
                        container.style.backgroundColor = "";
                    });
        
                    // Highlight the container of the selected radio button
                    const container = this.closest('.sub_container_4');
                    if (container) {
                        container.style.backgroundColor = "orange";
                        console.log(`🎯 Container ID: ${container.id} highlighted`);
                    }
        
                    // Extract index from radio ID
                    const match = this.id.match(/selected_radio(\d+)/);
                    if (match) {
                        const index = parseInt(match[1]); // 1-based index
                        const isSingle = window.fetchedResponse?.final_data?.single_double?.[index - 1];
        
                        const lowMasterBtn = document.getElementById("lowMasterBtn");
                        const highMasterBtn = document.getElementById("highMasterBtn");
                        const singleMasterBtn = document.getElementById("singleMasterBtn");
        
                        if (isSingle) {
                            if (lowMasterBtn) lowMasterBtn.style.display = "none";
                            if (highMasterBtn) highMasterBtn.style.display = "none";
                            if (singleMasterBtn) singleMasterBtn.style.display = "";
                            console.log(`✅ SINGLE MASTERING displayed for param ${index}`);
                        } else {
                            if (lowMasterBtn) lowMasterBtn.style.display = "";
                            if (highMasterBtn) highMasterBtn.style.display = "";
                            if (singleMasterBtn) singleMasterBtn.style.display = "none";
                            console.log(`✅ LOW/HIGH MASTERING displayed for param ${index}`);
                        }
                    } else {
                        console.warn("❌ Could not parse radio button index:", this.id);
                    }
        
                    // Update previous radio reference
                    if (previousSelectedRadio && previousSelectedRadio !== this) {
                        previousSelectedRadio.checked = false;
                    }
                    previousSelectedRadio = this;
                }
            });
        });
        
        
        
        
        });
        
        // ✅ Make these globally accessible
        function hideRadioButtons() {
            const selectedRadios = document.querySelectorAll('.selected_radio');
            selectedRadios.forEach((radio) => {
                radio.style.display = 'none';
            });
        }
        
        function showRadioButtons() {
            const selectedRadios = document.querySelectorAll('.selected_radio');
            selectedRadios.forEach((radio) => {
                radio.style.display = 'inline-block';
            });
        }
        
        
        
        // to display the input values in this:::::
        // Function to fetch and display values
        // Function to log the selected value from the dropdown
        // Function to log the selected value from the dropdown
        function logSelectedValue() {
            var masteringSelect = document.getElementById("mastering"); // Ensure correct element
            console.log("Selected value: " + masteringSelect.value);
            return masteringSelect.value;
        }
        
        // Delay execution for 2 seconds after page load
        window.onload = function() {
            setTimeout(() => {
                const selectedValue = logSelectedValue();
                fetchAndDisplayValues(selectedValue);
            },500);
        };
        
        // Listen for changes in the dropdown and fetch new values
        document.getElementById("mastering").addEventListener("change", function() {
            const selectedValue = logSelectedValue();
            fetchAndDisplayValues(selectedValue);
        });
        
        
        
        
        
        let calculationIntervals = {}; // Object to store interval IDs by index
        
        function calculateAndUpdateDisplayOutput(index, parameterValues, lowMaster, highMaster, lsl, usl, ltl, utl, probeNumber, digits, singleDoubleArray) {
            const textareaId = mapProbeToTextareaId(probeNumber);
            const textarea = document.getElementById(textareaId);
        
            if (!textarea) {
                console.warn(`❌ Textarea with ID ${textareaId} not found.`);
                return;
            }
        
            let lastValue = null; // Store last value to avoid unnecessary updates
        
            function updateCalculation() {
                const newSerialData = !isNaN(parseFloat(textarea.value)) ? parseFloat(textarea.value) : 0;
        
                if (newSerialData === lastValue) return; // Skip if value hasn't changed
                lastValue = newSerialData; // Update last value
        
                const matchingParameter = parameterValues.find(param => param.probe_number === probeNumber);
                if (!matchingParameter) {
                    console.warn(`⚠️ No matching parameter found for probe ${probeNumber}`);
                    return;
                }
        
                const e = parseFloat(matchingParameter.e) || 0;
                const d = parseFloat(matchingParameter.d) || 0;
                const o1 = parseFloat(matchingParameter.o1) || 0;
                const b = parseFloat(matchingParameter.b) || 0;
                const b1 = parseFloat(matchingParameter.b1) || 0;
        
                const isSingle = singleDoubleArray?.[index] === true;
        
                let displayOutput;
                if (isSingle) {
                    const displayOutput1 = (newSerialData - b1) * d;
                    displayOutput = displayOutput1 + e + b;
                    console.log(`🔹 Using SINGLE mastering formula for index ${index}`);
                } else {
                    displayOutput = e + (newSerialData * d + o1);
                    console.log(`🔸 Using DOUBLE mastering formula for index ${index}`);
                }
        
                if (!window.overrideDisplay) {
                    window.overrideDisplay = [];
                }
        
                const containerNumber = parseInt(window.fetchedResponse.final_data.fixed_channel[index]);
                const outputInput = document.getElementById(`center_input${containerNumber}`);
                if (outputInput) {
                    if (!window.overrideDisplay[index]) {
                        const decimalPlaces = parseFloat(digits[index]);
                        outputInput.value = !isNaN(decimalPlaces) ? displayOutput.toFixed(decimalPlaces) : displayOutput;
        
                        if (displayOutput >= lsl[index] && displayOutput <= usl[index]) {
                            outputInput.style.backgroundColor = "#00ff00"; // Green
                        } else if ((displayOutput > usl[index] && displayOutput <= utl[index]) ||
                            (displayOutput >= ltl[index] && displayOutput < lsl[index])) {
                            outputInput.style.backgroundColor = "yellow";
                        } else {
                            outputInput.style.backgroundColor = "red";
                        }
                    }
                }
            }
        
            if (calculationIntervals[index]) {
                clearInterval(calculationIntervals[index]);
            }
        
            calculationIntervals[index] = setInterval(updateCalculation, 100);
        }
        
        
        
        let fetchedData = null;
        let parameterValues = null;    
        
        function fetchAndDisplayValues(selectedMasterGroup) {
            const partName = $("#partModel").val();
        
            $.ajax({
                url: "{% url 'master' %}",
                method: "POST",
                headers: { "X-CSRFToken": "{{ csrf_token }}" },
                data: { part_name: partName },
                success: function (response) {
                   
                   
                    fetchedData = response.final_data;
                    console.log("✅ fetchedData:", fetchedData);
                    
                    parameterValues = response.parameter_values;
        
                    window.fetchedResponse = response;
                    window.selectedMasterGroup = selectedMasterGroup;
        
                    const lowMasterValues = fetchedData.low_master;
                    const highMasterValues = fetchedData.high_master;
                    const fixed_channel = fetchedData.fixed_channel;
                    const probeNumbers = fetchedData.channel_no;
                    const masterGroups = fetchedData.master_grp;
                    const digits = fetchedData.digits;
                    const singleDouble = fetchedData.single_double;
        
                    const availableContainers = fixed_channel.length;
        
                    const masteringSelect = document.getElementById("mastering");
        // Get current selected value before changing
        const currentSelected = masteringSelect.value;
        
        // Get unique group values from backend and sort them
        const masterGroupsValues = [...new Set(fetchedData.master_grp)].sort((a, b) => a - b);
        
        // Get existing dropdown values
        const existingOptions = Array.from(masteringSelect.options).map(opt => opt.value);
        
        // Check if current dropdown options match new options
        const isSame = masterGroupsValues.length === existingOptions.length &&
                       masterGroupsValues.every((val, idx) => val == existingOptions[idx]);
        
        if (!isSame) {
            // Only update if different
            masteringSelect.innerHTML = '';
        
            // Add default option
            const defaultOption = document.createElement("option");
            defaultOption.value = "";
            defaultOption.textContent = "-- Select Group --";
            masteringSelect.appendChild(defaultOption);
        
            // Add sorted options
            masterGroupsValues.forEach(value => {
                const option = document.createElement("option");
                option.value = value;
                option.textContent = value;
                masteringSelect.appendChild(option);
            });
        
            // Restore previously selected value if still valid
            if (masterGroupsValues.includes(currentSelected)) {
                masteringSelect.value = currentSelected;
            }
        }
        
                    
        
                    
        
                    let foundMatch = false; // 🔍 Tracks if any match was found
                    // Step 1: Mark all containers as blurred (reset state)
        for (let index = 1; index <= 8; index++) {
            const container = document.getElementById(`cal_container${index}`);
            const inputBox = document.getElementById(`para_name${index}`);
            const lowMasterInput = document.getElementById(`low_master${index}`);
            const highMasterInput = document.getElementById(`high_master${index}`);
        
            
        }
        
        // Step 2: Fill values only in the containers from fixed_channel[]
        for (let i = 0; i < fixed_channel.length; i++) {
            const ch = parseInt(fixed_channel[i]); // container number
            const probeNumber = probeNumbers[i];
            const isSelectedGroup = masterGroups[i] === selectedMasterGroup;
        
            const container = document.getElementById(`cal_container${ch}`);
            const inputBox = document.getElementById(`para_name${ch}`);
            const lowMasterInput = document.getElementById(`low_master${ch}`);
            const highMasterInput = document.getElementById(`high_master${ch}`);
        
            if (container) {
                container.style.filter = "none";
                container.style.backgroundColor = isSelectedGroup ? "orange" : "";
            }
        
            if (inputBox) {
                inputBox.style.display = "";
                inputBox.value = `CHANNEL-${ch}`;
            }
        
            if (lowMasterInput) lowMasterInput.value = lowMasterValues[i];
            if (highMasterInput) highMasterInput.value = highMasterValues[i];
        
            const textareaId = mapProbeToTextareaId(probeNumber);
            const textarea = document.getElementById(textareaId);
        
            if (textarea) {
                textarea.addEventListener("input", function () {
                    const val = textarea.value.trim();
                    const parsedValue = val === '' || isNaN(parseFloat(val)) ? 0 : parseFloat(val);
                    calculateAndUpdateDisplayOutput(
                        i,
                        parameterValues,
                        lowMasterValues[i],
                        highMasterValues[i],
                        fetchedData.lsl,
                        fetchedData.usl,
                        fetchedData.ltl,
                        fetchedData.utl,
                        probeNumber,
                        digits,
                        fetchedData.single_double
                    );
                });
        
                const initValue = textarea.value.trim();
                calculateAndUpdateDisplayOutput(
                    i,
                    parameterValues,
                    lowMasterValues[i],
                    highMasterValues[i],
                    fetchedData.lsl,
                    fetchedData.usl,
                    fetchedData.ltl,
                    fetchedData.utl,
                    probeNumber,
                    digits,
                    fetchedData.single_double
                );
            }
        }
        
                    // === Handle shared mastering buttons based on selected group ===
                    const selectedIndex = masterGroups.findIndex(g => g === selectedMasterGroup);
                    const isSingle = singleDouble[selectedIndex];
        
        
                    const lowMasterBtn = document.getElementById("lowMasterBtn");
                    const highMasterBtn = document.getElementById("highMasterBtn");
                    const singleMasterBtn = document.getElementById("singleMasterBtn");
        
                    if (isSingle) {
                        if (lowMasterBtn) lowMasterBtn.style.display = "none";
                        if (highMasterBtn) highMasterBtn.style.display = "none";
                        if (singleMasterBtn) singleMasterBtn.style.display = "";
                        console.log("✅ Showing SINGLE MASTERING button");
                    } else {
                        if (lowMasterBtn) lowMasterBtn.style.display = "";
                        if (highMasterBtn) highMasterBtn.style.display = "";
                        if (singleMasterBtn) singleMasterBtn.style.display = "none";
                        console.log("✅ Showing LOW/HIGH MASTERING buttons");
                    }
        
                    // === UI highlight logic for radio selection ===
                    const parameterwiseRadio = document.getElementById("parameterwise");
        
                    if (parameterwiseRadio && parameterwiseRadio.checked) {
                        // Clear all orange backgrounds
                        document.querySelectorAll(".sub_container_4").forEach(container => {
                            container.style.backgroundColor = "";
                        });
        
                        // Highlight the selected one
                        const selectedRadio = document.querySelector(".selected_radio:checked");
                       
                        if (selectedRadio) {
                            const match = selectedRadio.id.match(/selected_radio(\d+)/);
                            if (match) {
                                const index = match[1];
                                const container = document.getElementById(`cal_container${index}`);
                                if (container) {
                                    container.style.backgroundColor = "orange";
                                }
                            }
                        }
                    }
                },
                error: function (error) {
                    console.error("❌ Error fetching data:", error);
                }
            });
        }
        
        
        
        function reapplyHighlight() {
            const masterGroups = window.fetchedResponse.final_data.master_grp;
            const selectedGroup = window.selectedMasterGroup;
        
            for (let i = 1; i <= 8; i++) {
                const container = document.getElementById(`cal_container${i}`);
                if (!container) continue;
        
                container.style.backgroundColor =
                    i <= masterGroups.length && masterGroups[i - 1] == selectedGroup
                        ? "orange"
                        : "";
            }
        }
        
        
        
        
        document.getElementById("lowMasterBtn").addEventListener("click", function () {
    console.clear();
    console.log("Low Mastering button clicked.");

    if (!parameterValues) {
        console.warn("⚠️ parameterValues not loaded yet. Please fetch master data first.");
        return;
    }

    console.log("parameterValues", parameterValues);

    const masteringSelect = document.getElementById("mastering");
    const selectedMasteringValue = masteringSelect.value;
    masteringSelect.disabled = true;

    const response = window.fetchedResponse;
    if (!response) {
        console.error("No data available. Please call 'fetchAndDisplayValues' first.");
        return;
    }

    const lowmaster = response.final_data.low_master;
    const probe_number = response.final_data.channel_no;
    const step_no = response.final_data.master_grp;

    // ✅ DEFINE LIMIT ARRAYS
    const lsl = response.final_data.lsl;
    const usl = response.final_data.usl;
    const ltl = response.final_data.ltl;
    const utl = response.final_data.utl;

    window.lowmasterValues = [];
    window.lowmasterA1Values = [];
    if (!window.overrideDisplay) window.overrideDisplay = [];
    if (!window.lowMasterParams) window.lowMasterParams = {};

    const isAllParameterSelected = document.getElementById("all_parameter").checked;
    const isParameterwiseSelected = document.getElementById("parameterwise").checked;

    if (isAllParameterSelected) {
        console.log("All Parameters selected.");

        lowmaster.forEach((lowValue, index) => {
            if (step_no[index] == selectedMasteringValue) {
                const a = parseFloat(lowValue) || 0;
                const probeNumber = probe_number[index];
                const textareaId = mapProbeToTextareaId(probeNumber);
                const textarea = document.getElementById(textareaId);
                const a1 = textarea ? parseFloat(textarea.value) || 0 : 0;

                const paramObj = parameterValues.find(obj => obj.probe_number == probeNumber);
                if (!paramObj) {
                    console.warn(`⚠️ No parameterValues found for probe_number: ${probeNumber}`);
                    return;
                }

                const b = parseFloat(paramObj.b);
                const b1 = parseFloat(paramObj.b1);
                const e = parseFloat(paramObj.e);
                const d = parseFloat(paramObj.d);
                const o1 = parseFloat(paramObj.o1);

                console.log(`Container ${index + 1}:`);
                console.log("Low Master value (a):", a);
                console.log("Textarea value (a1):", a1);

                window.lowmasterValues[index] = a;
                window.lowmasterA1Values[index] = a1;

                const lowRawMasterInput = document.getElementById(`low_raw_count${index + 1}`);
                if (lowRawMasterInput) {
                    lowRawMasterInput.value = a1;
                }

                const outputInput = document.getElementById(`center_input${index + 1}`);
                if (outputInput && textarea) {
                    window.overrideDisplay[index] = true;

                    const c = b - a;
                    const c1 = b1 - a1 || 1; // avoid divide by zero
                    const dVal = c / c1;
                    const oVal = e + (a1 * dVal);
                    const o1Val = a - oVal;

                    const newSerialData = parseFloat(textarea.value);
                    if (!isNaN(newSerialData)) {
                        const displayOutput = e + (newSerialData * dVal + o1Val);
                        outputInput.value = displayOutput.toFixed(4);

                        if (typeof lsl !== "undefined" && typeof usl !== "undefined" &&
                            typeof ltl !== "undefined" && typeof utl !== "undefined") {
                            const k = displayOutput;
                            if (k >= lsl && k <= usl) {
                                outputInput.style.backgroundColor = '#00ff00';
                            } else if ((k > usl && k <= utl) || (k >= ltl && k < lsl)) {
                                outputInput.style.backgroundColor = 'yellow';
                            } else if (k > utl || k < ltl) {
                                outputInput.style.backgroundColor = 'red';
                            }
                        } else {
                            outputInput.style.backgroundColor = "red";
                        }
                    }

                    // ✅ Define the handler function to store and remove later
                    const inputHandler = function () {
                        const serialValue = parseFloat(this.value);
                        const params = window.lowMasterParams[index];
                        if (!params || isNaN(serialValue)) return;

                        const { d, o1, e, outputInput } = params;
                        const displayOutput = e + (serialValue * d + o1);
                        outputInput.value = displayOutput.toFixed(4);

                        if (typeof lsl !== "undefined" && typeof usl !== "undefined" &&
                            typeof ltl !== "undefined" && typeof utl !== "undefined") {
                            const k = displayOutput;
                            if (k >= lsl && k <= usl) {
                                outputInput.style.backgroundColor = '#00ff00';
                            } else if ((k > usl && k <= utl) || (k >= ltl && k < lsl)) {
                                outputInput.style.backgroundColor = 'yellow';
                            } else if (k > utl || k < ltl) {
                                outputInput.style.backgroundColor = 'red';
                            }
                        } else {
                            outputInput.style.backgroundColor = "red";
                        }
                    };

                    // ✅ Store params with handler and textarea for cleanup
                    window.lowMasterParams[index] = {
                        d: dVal,
                        o1: o1Val,
                        e: e,
                        outputInput: outputInput,
                        handler: inputHandler,
                        textarea: textarea
                    };

                    textarea.addEventListener("input", inputHandler);
                }

                const preInput = document.getElementById('pre');
                if (preInput) {
                    preInput.value = "LOW MASTERING COMPLETED , DO HIGH MASTERING";
                }
            }
        });
    }

   
            
            
            
    else if (isParameterwiseSelected) {
    console.clear();
    console.log("Parameterwise selected.");

    const selectedContainer = Array.from(document.querySelectorAll(".selected_radio"))
        .find(radio => radio.checked);

    if (!selectedContainer) {
        showCustomAlert("PLEASE SELECT THE CHANNEL NO!.");
        setTimeout(() => location.reload(), 2000);
        return;
    }

    const selectedContainerId = selectedContainer.id;
    const selectedFixedChannel = parseInt(selectedContainerId.replace("selected_radio", ""));

    // ✅ Use actual index into arrays
    const actualIndex = response.final_data.fixed_channel.findIndex(fc => parseInt(fc) === selectedFixedChannel);

    if (actualIndex === -1) {
        showCustomAlert("Selected container not found in data.");
        return;
    }

    const a = parseFloat(lowmaster[actualIndex]) || 0;
    const step = step_no[actualIndex];
    const probeNumber = probe_number[actualIndex];
    const textareaId = mapProbeToTextareaId(probeNumber);
    const textarea = document.getElementById(textareaId);
    const a1 = textarea ? parseFloat(textarea.value) || 0 : 0;

    const paramObj = parameterValues.find(obj => obj.probe_number == probeNumber);
    if (!paramObj) {
        console.warn(`⚠️ No parameterValues found for probe_number: ${probeNumber}`);
        return;
    }

    const b = parseFloat(paramObj.b);
    const b1 = parseFloat(paramObj.b1);
    const e = parseFloat(paramObj.e);
    const d = parseFloat(paramObj.d);

    console.log(`Fixed Channel ${selectedFixedChannel} → Index ${actualIndex}`);
    console.log("Low Master value (a):", a);
    console.log("Textarea value (a1):", a1);

    if (step == selectedMasteringValue) {
        window.lowmasterValues[actualIndex] = a;
        window.lowmasterA1Values[actualIndex] = a1;

        const lowRawMasterInput = document.getElementById(`low_raw_count${selectedFixedChannel}`);
        if (lowRawMasterInput) {
            lowRawMasterInput.value = a1;
        }

        const outputInput = document.getElementById(`center_input${selectedFixedChannel}`);
        if (outputInput && textarea) {
            window.overrideDisplay[actualIndex] = true;

            const c = b - a;
            const c1 = b1 - a1 || 1;
            const dVal = c / c1;
            const oVal = e + (a1 * dVal);
            const o1Val = a - oVal;

            const newSerialData = parseFloat(textarea.value);
            if (!isNaN(newSerialData)) {
                const displayOutput = e + (newSerialData * dVal + o1Val);
                outputInput.value = displayOutput.toFixed(4);

                const k = displayOutput;
                if (k >= lsl[actualIndex] && k <= usl[actualIndex]) {
                    outputInput.style.backgroundColor = '#00ff00';
                } else if ((k > usl[actualIndex] && k <= utl[actualIndex]) || (k >= ltl[actualIndex] && k < lsl[actualIndex])) {
                    outputInput.style.backgroundColor = 'yellow';
                } else {
                    outputInput.style.backgroundColor = 'red';
                }
            }

            const inputHandler = function () {
                const serialValue = parseFloat(this.value);
                const params = window.lowMasterParams[actualIndex];
                if (!params || isNaN(serialValue)) return;

                const { d, o1, e, outputInput } = params;
                const displayOutput = e + (serialValue * d + o1);
                outputInput.value = displayOutput.toFixed(4);

                const k = displayOutput;
                if (k >= lsl[actualIndex] && k <= usl[actualIndex]) {
                    outputInput.style.backgroundColor = '#00ff00';
                } else if ((k > usl[actualIndex] && k <= utl[actualIndex]) || (k >= ltl[actualIndex] && k < lsl[actualIndex])) {
                    outputInput.style.backgroundColor = 'yellow';
                } else {
                    outputInput.style.backgroundColor = 'red';
                }
            };

            window.lowMasterParams[actualIndex] = {
                d: dVal,
                o1: o1Val,
                e: e,
                outputInput: outputInput,
                handler: inputHandler,
                textarea: textarea
            };

            textarea.addEventListener("input", inputHandler);
        }

        const preInput = document.getElementById('pre');
        if (preInput) {
            preInput.value = "LOW MASTERING COMPLETED, DO HIGH MASTERING";
        }

    } else {
        showCustomAlert("The selected channel does not match the mastering group.");
        setTimeout(() => location.reload(), 3000);
    }
}

        
        });




        
        
        // ✅ UPDATED FULL HIGH MASTERING BUTTON HANDLER WITH CORRECT CONTAINER MAPPING
        
        document.getElementById("highMasterBtn").addEventListener("click", function () {
    console.log("High Mastering button clicked.");

    // 🧹 Clear low mastering handlers
    if (window.lowMasterParams) {
        Object.values(window.lowMasterParams).forEach(param => {
            if (param.textarea && param.handler) {
                param.textarea.removeEventListener("input", param.handler);
            }
        });
        window.lowMasterParams = {};
    }

    const masteringSelect = document.getElementById("mastering");
    const selectedMasteringValue = masteringSelect.value;
    masteringSelect.disabled = false;

    const response = window.fetchedResponse;
    if (!response) {
        console.error("No data available. Please call 'fetchAndDisplayValues' first.");
        return;
    }

    const {
        high_master,
        low_master,
        channel_no,
        nominal,
        master_grp,
        lsl,
        usl,
        ltl,
        utl,
        id_od,
        digits,
        fixed_channel,
        step_no
    } = response.final_data;

    const isAllParameterSelected = document.getElementById("all_parameter").checked;
    const isParameterwiseSelected = document.getElementById("parameterwise").checked;

    if (isAllParameterSelected) {
        console.log("All Parameters selected.");

        let allPassed = true;
        const validIndices = [];

        high_master.forEach((highValue, index) => {
            if (master_grp[index] == selectedMasteringValue) {
                const b = parseFloat(highValue) || 0;
                const a = parseFloat(low_master[index]) || 0;

                const probeNumber = channel_no[index];
                const textareaId = mapProbeToTextareaId(probeNumber);
                const textarea = document.getElementById(textareaId);
                const b1 = textarea ? parseFloat(textarea.value) || 0 : 0;
                const a1 = window.lowmasterA1Values[index] || 0;

                const jobDia = id_od[index];
                const difference = Math.abs(a1 - b1);

                if ((jobDia === "OD" && (b1 <= a1 || difference < 1000)) ||
                    (jobDia === "ID" && (b1 >= a1 || difference < 1000))) {
                    showCustomAlert(`DO PROPER MASTERING`);
                    const preInput = document.getElementById('pre');
                    preInput.value = "DO MASTERING ";
                    allPassed = false;
                } else {
                    validIndices.push(index);
                }
            }
        });

        if (!allPassed) return;

        // ✅ Final display calculation for each valid index
        validIndices.forEach(index => {
            const a = parseFloat(low_master[index]) || 0;
            const b = parseFloat(high_master[index]) || 0;
            const a1 = window.lowmasterA1Values[index] || 0;

            const probeNumber = channel_no[index];
            const textareaId = mapProbeToTextareaId(probeNumber);
            const textarea = document.getElementById(textareaId);
            const b1 = textarea ? parseFloat(textarea.value) || 0 : 0;

            const containerNumber = parseInt(fixed_channel[index]);

            // 🔁 CALL performCalculations
            performCalculations(
                a,
                a1,
                b,
                b1,
                nominal[index],
                index,
                containerNumber,
                textareaId,
                lsl[index],
                usl[index],
                ltl[index],
                utl[index],
                step_no[index],
                digits
            );

            // Optional raw master display
            const highRawMasterInput = document.getElementById(`high_raw_count${containerNumber}`);
            if (highRawMasterInput) {
                highRawMasterInput.value = b1;
            }

            const preInput = document.getElementById('pre');
            if (preInput) preInput.value = "HIGH MASTERING COMPLETED";
        });
    }


    else if (isParameterwiseSelected) {
    console.log("Parameterwise selected.");

    const selectedContainer = Array.from(document.querySelectorAll(".selected_radio"))
        .find(radio => radio.checked);

    if (!selectedContainer) {
        showCustomAlert("PLEASE SELECT THE CHANNEL NO!.");
        setTimeout(() => location.reload(), 2000);
        return;
    }

    const selectedFixedChannel = parseInt(selectedContainer.id.replace("selected_radio", ""));
    const actualIndex = fixed_channel.findIndex(fc => parseInt(fc) === selectedFixedChannel);

    if (actualIndex === -1) {
        showCustomAlert("Selected container not found in data.");
        return;
    }

    if (step_no[actualIndex] == selectedMasteringValue) {
        const a = parseFloat(low_master[actualIndex]) || 0;
        const a1 = window.lowmasterA1Values[actualIndex] || 0;
        const b = parseFloat(high_master[actualIndex]) || 0;

        const probeNumber = channel_no[actualIndex];
        const textareaId = mapProbeToTextareaId(probeNumber);
        const textarea = document.getElementById(textareaId);
        const b1 = textarea ? parseFloat(textarea.value) || 0 : 0;

        const jobDia = id_od[actualIndex];
        const difference = Math.abs(a1 - b1);

        if (
            (jobDia === "OD" && (b1 <= a1 || difference < 1000)) ||
            (jobDia === "ID" && (b1 >= a1 || difference < 1000))
        ) {
            showCustomAlert("DO PROPER MASTERING");
            const preInput = document.getElementById('pre');
            if (preInput) preInput.value = "DO MASTERING ";
            return;
        }

        performCalculations(
            a,
            a1,
            b,
            b1,
            nominal[actualIndex],
            actualIndex,
            selectedFixedChannel,
            textareaId,
            lsl[actualIndex],
            usl[actualIndex],
            ltl[actualIndex],
            utl[actualIndex],
            step_no[actualIndex],
            digits
        );

        const highRawMasterInput = document.getElementById(`high_raw_count${selectedFixedChannel}`);
        if (highRawMasterInput) {
            highRawMasterInput.value = b1;
        }

        const preInput = document.getElementById('pre');
        if (preInput) preInput.value = "HIGH MASTERING COMPLETED ";
    } else {
        showCustomAlert("The selected container does not match the mastering group.");
    }
}

        
        });
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        document.getElementById("singleMasterBtn").addEventListener("click", function () {
            console.log("🟠 Single Mastering button clicked.");
        
            const masteringSelect = document.getElementById("mastering");
            const selectedMasteringValue = masteringSelect.value;
        
            const response = window.fetchedResponse;
            if (!response) {
                console.error("❌ No data available. Please call 'fetchAndDisplayValues' first.");
                return;
            }
        
            const nominals = response.final_data.nominal;
            const lsl = response.final_data.lsl;
            const usl = response.final_data.usl;
            const ltl = response.final_data.ltl;
            const utl = response.final_data.utl;
            const id_od = response.final_data.id_od;
            const digits = response.final_data.digits;
            const singleDouble = response.final_data.single_double;
            const singleMaster = response.final_data.low_master;
            const singleMasterHigh = response.final_data.high_master;
            const probe_number = response.final_data.channel_no;
            const step_no = response.final_data.master_grp;
            const fixed_channel = response.final_data.fixed_channel;
        
            const isAllParameterSelected = document.getElementById("all_parameter").checked;
            const isParameterwiseSelected = document.getElementById("parameterwise").checked;
        
            // ✅ ALL PARAMETERS
            if (isAllParameterSelected) {
                console.log("🧠 Mode: ALL PARAMETERS");
        
                singleDouble.forEach((isSingle, index) => {
                    if (isSingle && step_no[index] == selectedMasteringValue) {
                        const a = parseFloat(singleMaster[index]) || 0;
                        const b = parseFloat(singleMasterHigh[index]) || 0;
                        const a1 = 0;
                        const probeNumber = probe_number[index];
                        const containerNumber = parseInt(fixed_channel[index]);
                        const textareaId = mapProbeToTextareaId(probeNumber);
                        const textarea = document.getElementById(textareaId);
                        let b1 = 0;
        
                        if (textarea) {
                            b1 = parseFloat(textarea.value) || 0;
                            if (b1 === 0) {
                                showCustomAlert("DO PROPER SINGLE MASTERING !");
                                return;
                            }
                        } else {
                            showCustomAlert("DO PROPER SINGLE MASTERING !");
                            return;
                        }
        
                        console.log(`📦 Container ${containerNumber}: SINGLE`);
                        console.log("🔹 Analog Zero (a):", a, "| a1:", a1);
                        console.log("🔸 Reference (b):", b, "| b1:", b1);
        
                        const analogZeroInput = document.getElementById(`low_raw_count${containerNumber}`);
                        if (analogZeroInput) analogZeroInput.value = a1;
        
                        const referenceInput = document.getElementById(`high_raw_count${containerNumber}`);
                        if (referenceInput) referenceInput.value = b1;
        
                        const nominalValue = nominals[index] || 0;
        
                        performSingleCalculations(
                            a,
                            a1,
                            b,
                            b1,
                            nominalValue,
                            index,
                            containerNumber,  // ✅ this is fixed_channel
                            textareaId,
                            lsl[index],
                            usl[index],
                            ltl[index],
                            utl[index],
                            step_no[index],
                            digits
                        );
        
                        const preInput = document.getElementById('pre');
                        if (preInput) preInput.value = "SINGLE MASTERING IS STARTED";
                    }
                });
        
            // ✅ PARAMETERWISE
            } else if (isParameterwiseSelected) {
                console.log("🧠 Mode: PARAMETERWISE");
        
                const selectedRadio = Array.from(document.querySelectorAll(".selected_radio"))
                    .find(radio => radio.checked);
        
                if (!selectedRadio) {
                    showCustomAlert("Please select a channel.");
                    setTimeout(() => location.reload(), 1000);
                    return;
                }
        
                const selectedFixedChannel = parseInt(selectedRadio.id.replace("selected_radio", ""));
                const actualIndex = fixed_channel.findIndex(fc => parseInt(fc) === selectedFixedChannel);
        
                if (actualIndex === -1) {
                    showCustomAlert("Selected channel not found in data.");
                    return;
                }
        
                if (singleDouble[actualIndex] && step_no[actualIndex] == selectedMasteringValue) {
                    const a = parseFloat(singleMaster[actualIndex]) || 0;
                    const b = parseFloat(singleMasterHigh[actualIndex]) || 0;
                    const a1 = 0;
                    const probeNumber = probe_number[actualIndex];
                    const textareaId = mapProbeToTextareaId(probeNumber);
                    const textarea = document.getElementById(textareaId);
                    let b1 = 0;
        
                    if (textarea) {
                        b1 = parseFloat(textarea.value) || 0;
                        if (b1 === 0) {
                            showCustomAlert("DO PROPER SINGLE MASTERING !");
                            return;
                        }
                    } else {
                        showCustomAlert("DO PROPER SINGLE MASTERING !");
                        return;
                    }
        
                    console.log(`📦 Selected Container ${selectedFixedChannel}: SINGLE`);
                    console.log("🔹 Analog Zero (a):", a, "| a1:", a1);
                    console.log("🔸 Reference (b):", b, "| b1:", b1);
        
                    const analogZeroInput = document.getElementById(`low_raw_count${selectedFixedChannel}`);
                    if (analogZeroInput) analogZeroInput.value = a1;
        
                    const referenceInput = document.getElementById(`high_raw_count${selectedFixedChannel}`);
                    if (referenceInput) referenceInput.value = b1;
        
                    const nominalValue = nominals[actualIndex] || 0;
        
                    performSingleCalculations(
                        a,
                        a1,
                        b,
                        b1,
                        nominalValue,
                        actualIndex,
                        selectedFixedChannel,  // ✅ passed correctly
                        textareaId,
                        lsl[actualIndex],
                        usl[actualIndex],
                        ltl[actualIndex],
                        utl[actualIndex],
                        step_no[actualIndex],
                        digits
                    );
        
                    const preInput = document.getElementById('pre');
                    if (preInput) preInput.value = "SINGLE MASTERING IS STARTED";
                } else {
                    showCustomAlert("This channel does not use SINGLE mastering.");
                    setTimeout(() => location.reload(), 1000);
                }
        
            // ❌ No valid mode selected
            } else {
                showCustomAlert("Please select either 'ALL CHANNELS' or 'CHANNELWISE'.");
                setTimeout(() => location.reload(), 1000);
            }
        });
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        function performSingleCalculations(a, a1, b, b1, e, index, containerNumber, textareaId, lsl, usl, ltl, utl, step_no, digits) {
            console.log("🧮 Performing Single Mastering Calculations");
        
            a = parseFloat(a);
            a1 = parseFloat(a1);
            b = parseFloat(b);
            b1 = parseFloat(b1);
            e = parseFloat(e);
            lsl = parseFloat(lsl);
            usl = parseFloat(usl);
            ltl = parseFloat(ltl);
            utl = parseFloat(utl);
            digits = parseFloat(digits[index]);
        
            const response = window.fetchedResponse;
            const probe_number = response.final_data.channel_no;
            const masteringSelect = document.getElementById("mastering");
            const selectedMasteringValue = masteringSelect.value;
            const partName = $("#partModel").val();
            const dateTime = document.getElementById("clock-box").value;
            const probeNumber = probe_number[index];
        
            const c = b - 0;
            const c1 = b1 - 0;
            const d = 0.0003246;
            const o = 0;
            const o1 = 0;
        
            const textarea = document.getElementById(textareaId);
            const outputInput = document.getElementById(`center_input${containerNumber}`);
        
            if (textarea && outputInput) {
                const newSerialData = parseFloat(textarea.value);
                if (!isNaN(newSerialData)) {
                    const displayOutput1 = (newSerialData - b1) * d;
                    const displayOutput = displayOutput1 + e + b;
        
                    outputInput.value = displayOutput.toFixed(digits);
                    console.log("📏 displayOutput:", displayOutput.toFixed(digits));
        
                    if (displayOutput >= lsl && displayOutput <= usl) {
                        outputInput.style.backgroundColor = '#00ff00';
                    } else if ((displayOutput > usl && displayOutput <= utl) || (displayOutput >= ltl && displayOutput < lsl)) {
                        outputInput.style.backgroundColor = 'yellow';
                    } else if (displayOutput > utl || displayOutput < ltl) {
                        outputInput.style.backgroundColor = 'red';
                    }
        
                    // 📨 Send POST request
                    const payload = [{
                        a, a1, b, b1, e, d, o1, part_model: partName,
                        date_time: dateTime, mastering: selectedMasteringValue, probeNumber, containerNumber
                    }];
                    console.log("🔁 Sending to backend:", payload);
        
                    fetch('/data/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Requested-With': 'XMLHttpRequest'
                        },
                        body: JSON.stringify({ payload })
                    })
                    .then(response => response.json())
                    .then(data => {
                        console.log("📩 Response from backend:", data);
                        if (data.message) {
                            outputInput.value = ""; // Clear field
                            console.log(`✅ Cleared center_input${containerNumber}`);
        
                            const notification = document.createElement('div');
                            notification.style = `
                                position: fixed; top: 5%; left: 35%; width: 30%; height: 20%;
                                display: flex; align-items: center; justify-content: center;
                                z-index: 1000; color: white; font-size: 1.5rem;
                                font-weight: bold; border-radius: 10px;
                                background-color: green;`;
                            notification.textContent = data.message;
        
                            document.body.appendChild(notification);
                            setTimeout(() => document.body.removeChild(notification), 2000);
                        }
                    })
                    .catch(error => {
                        console.error("❌ Error in POST request:", error);
                    });
                } else {
                    console.warn("⚠️ Serial data is NaN or empty.");
                }
            } else {
                console.warn("⚠️ Textarea or Output input not found for container:", containerNumber);
            }
        
            // ⏳ Highlight logic
            setTimeout(() => {
                const parameterwiseRadio = document.getElementById("parameterwise");
                const allParameterRadio = document.getElementById("all_parameter");
                const preInput = document.getElementById('pre');
        
                document.querySelectorAll(".sub_container_4").forEach(container => {
                    container.style.backgroundColor = "";
                });
        
                if (allParameterRadio && allParameterRadio.checked) {
                    preInput.value = " ALL CHANNELS IS SELECTED , DO MASTERING ";
                    fetchAndDisplayValues(window.selectedMasterGroup);
                } else if (parameterwiseRadio && parameterwiseRadio.checked) {
                    preInput.value = " CHANNELWISE IS SELECTED , DO MASTERING ";
                    fetchAndDisplayValues();
        
                    const selectedRadio = document.querySelector(".selected_radio:checked");
                    if (selectedRadio) {
                        const match = selectedRadio.id.match(/selected_radio(\d+)/);
                        if (match) {
                            const idx = match[1];
                            const container = document.getElementById(`cal_container${idx}`);
                            if (container) {
                                container.style.backgroundColor = "orange";
                            }
                        }
                    }
                } else {
                    console.warn("⚠️ No mode selected.");
                }
            }, 1000);
        }
        
        
        
        
        
        
        
        
        function performCalculations(a, a1, b, b1, e, index, containerNumber, textareaId, lsl, usl, ltl, utl, step_no, digits) {
        console.log("containerNumber jjjjjjjjjjjjjjjjjjjjqqqqqqqqqqqqqqqqqqqqqq",containerNumber)
            a = parseFloat(a);
            a1 = parseFloat(a1);
            b = parseFloat(b);
            b1 = parseFloat(b1);
            e = parseFloat(e);
            lsl = parseFloat(lsl);
            usl = parseFloat(usl);
            ltl = parseFloat(ltl);
            utl = parseFloat(utl);
            step_no = parseFloat(step_no);
            digits = parseFloat(digits[index]);
        
            const response = window.fetchedResponse;
            const probe_number = response.final_data.channel_no;
            const masteringSelect = document.getElementById("mastering");
            const selectedMasteringValue = masteringSelect.value;
            const partName = $("#partModel").val();
            const dateTime = document.getElementById("clock-box").value;
            const probeNumber = probe_number[index];
        
            const c = b - a;
            const c1 = b1 - a1;
            const d = c / c1;
            const o = e + (a1 * d);
            const o1 = a - o;
        
            const textarea = document.getElementById(textareaId);
            const outputInput = document.getElementById(`center_input${containerNumber}`);
            console.log("outputInput",outputInput)
        
            if (textarea && outputInput) {
                function updateDisplayOutput() {
                    const newSerialData = parseFloat(textarea.value);
                    if (!isNaN(newSerialData)) {
                        const displayOutput = e + (newSerialData * d + o1);
                        outputInput.value = displayOutput.toFixed(digits);
        
                        var k = displayOutput;
                        if (k >= lsl && k <= usl) {
                            outputInput.style.backgroundColor = '#00ff00'; // Green
                        } else if ((k > usl && k <= utl) || (k >= ltl && k < lsl)) {
                            outputInput.style.backgroundColor = 'yellow';
                        } else if (k > utl || k < ltl) {
                            outputInput.style.backgroundColor = 'red';
                        }
                    }
                }
        
                // Optional: call this immediately if needed
                
                // updateDisplayOutput();
        
                textarea.addEventListener('input', updateDisplayOutput);
                 // 👇 Ensure update runs after textarea.value is correct
    setTimeout(updateDisplayOutput, 100);
            }
        
            // Send payload to backend
            const payload = [{
                a, a1, b, b1, e, d, o1, part_model: partName,
                date_time: dateTime, mastering: selectedMasteringValue, probeNumber,containerNumber
            }];
        
            fetch('/data/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                },
                body: JSON.stringify({ payload })
            })
            .then(response => response.json())
            .then(data => {
                console.log("Response from backend:", data);
        
                // Clear the output input if successful
                if (data.message) {
                    if (outputInput) {
                        outputInput.value = ""; // Clear display
                        console.log(`Cleared input for center_input${containerNumber}`);
                    }
        
                    // Show green alert message
                    const notification = document.createElement('div');
                    notification.style = `
                        position: fixed; top: 5%; left: 15%; width: 50%; height: 25%;
                        display: flex; align-items: center; justify-content: center;
                        z-index: 1000; color: white; font-size:4vw;
                        font-weight: bold; border-radius: 10px;
                        background-color: green;
                    `;
                    notification.textContent = data.message;
                    document.body.appendChild(notification);
                    setTimeout(() => document.body.removeChild(notification), 2000);
                }
            })
            .catch(error => console.error("Error:", error));
        
            // Post-calculation logic
            setTimeout(() => {
                const parameterwiseRadio = document.getElementById("parameterwise");
                const allParameterRadio = document.getElementById("all_parameter");
                const preInput = document.getElementById('pre');
        
                // Reset all highlights
                document.querySelectorAll(".sub_container_4").forEach(container => {
                    container.style.backgroundColor = "";
                });
        
                if (allParameterRadio && allParameterRadio.checked) {
                    preInput.value = " ALL CHANNELS IS SELECTED , DO MASTERING ";
                    fetchAndDisplayValues(window.selectedMasterGroup);
                } else if (parameterwiseRadio && parameterwiseRadio.checked) {
                    preInput.value = " CHANNELWISE IS SELECTED , DO MASTERING ";
        
                    const selectedRadio = document.querySelector(".selected_radio:checked");
                    fetchAndDisplayValues();
        
                    if (selectedRadio) {
                        const match = selectedRadio.id.match(/selected_radio(\d+)/);
                        if (match) {
                            const targetContainerId = `cal_container${match[1]}`;
                            const container = document.getElementById(targetContainerId);
                            if (container) {
                                container.style.backgroundColor = "orange";
                            }
                        }
                    }
                }
            }, 1000);
        }
        
        
        
        
        
        
        
        
        //////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////
        
        // Function to map probe numbers to textarea IDs
        function mapProbeToTextareaId(probeNumber) {
            const probeMapping = {
                1: "probe-A",
                2: "probe-B",
                3: "probe-C",
                4: "probe-D",
        
                5: "probe-E",
                6: "probe-F",
                7: "probe-G",
                8: "probe-H",
        
                9: "probe-I",
                10: "probe-J",
                11: "probe-K",
                
            };
        
            return probeMapping[probeNumber] || null; // Return null if no mapping is found
        }
        
        
        
        
        //////////////////////////////////////////
        /////////////////////////////////////////
        function showCustomAlert(message) {
            const alertDiv = document.getElementById("customAlert");
            const messageDiv = document.getElementById("customAlertMessage");
            messageDiv.innerHTML = message;
            alertDiv.style.display = "block";
        }
        
        document.getElementById("customAlertCloseBtn").addEventListener("click", function () {
            document.getElementById("customAlert").style.display = "none";
        });
                          
        
        
        
        
        $(document).ready(function () {
            const ws = new WebSocket('ws://localhost:8000/ws/comport/');
        
            const messageBox = document.getElementById("message"); // Get the input box
        
            let dataReceived = false; // Track if data is received
        
            ws.onopen = function () {
                // Set initial disconnected state until data is received
                messageBox.value = "Disconnected";
                messageBox.style.color = "black";
                messageBox.style.backgroundColor = "red";
            };
        
            ws.onmessage = function(event) {
                const data = JSON.parse(event.data);
        
                if (data.message) {
                    dataReceived = true; // Mark data as received
        
                    // Match "+" pattern
                    const plusChannels = data.message.match(/[A-K]\+[^\+A-K]*/g);
                    if (plusChannels) {
                        plusChannels.forEach(channel => {
                            const channelId = channel.charAt(0);
                            const channelData = channel.charAt(1) + channel.substr(2); // Keep the +
                            $(`#probe-${channelId}`).val(channelData);
                        });
                    }
        
                    // Match "-" pattern
                    const minusChannels = data.message.match(/[A-K]\-[^\-A-K]*/g);
                    if (minusChannels) {
                        minusChannels.forEach(channel => {
                            const channelId = channel.charAt(0);
                            const channelData = channel.charAt(1) + channel.substr(2); // Keep the +
                            $(`#probe-${channelId}`).val(channelData);
                        });
                    }
        
                    // Display success message with green background and black text
                    messageBox.value = "Connected";
                    messageBox.style.color = "black";
                    messageBox.style.backgroundColor = "green";
                }
            };
        
            ws.onerror = function () {
                // Display error message with red background and black text
                messageBox.value = "Disconnected";
                messageBox.style.color = "black";
                messageBox.style.backgroundColor = "red";
            };
        
            ws.onclose = function () {
                if (!dataReceived) { // Check if data was never received
                    // Display error message with red background and black text
                    messageBox.value = "Disconnected";
                    messageBox.style.color = "black";
                    messageBox.style.backgroundColor = "red";
                }
            };
        });
        
        ////////////////////////////////////////////////
        
        function handleParameterSelection(key) {
            const parameterwiseRadio = document.getElementById("parameterwise");
            parameterwiseRadio.checked = true;
            parameterwiseRadio.dispatchEvent(new Event("change"));
        
            showRadioButtons(); // ✅ This now works since it's globally defined
        
            const keyToIndex = {
                "C1": 1,
                "C2": 2,
                "C3": 3,
                "C4": 4,
                "C5": 5,
                "C6": 6
            };
        
            const index = keyToIndex[key];
            const radio = document.getElementById(`selected_radio${index}`);
            const container = document.getElementById(`cal_container${index}`);
        
            if (radio) {
                radio.checked = true;
                radio.dispatchEvent(new Event("change")); // ✅ Triggers any listeners
            } else {
                console.warn(`Radio selected_radio${index} not found`);
            }
        
            // Clear other backgrounds
            document.querySelectorAll('.sub_container_4').forEach(cont => {
                cont.style.backgroundColor = "";
            });
        
            if (container) {
                container.style.backgroundColor = "orange";
            } else {
                console.warn(`Container cal_container${index} not found`);
            }
        
            const preInput = document.getElementById('pre');
            preInput.value = `PARAMETERWISE IS SELECTED (C${index})`;
        }
        
        
        
        let toggleState = true; // Start with true to click lowMasterBtn first
        
        const keyboardSocket = new WebSocket("ws://" + window.location.host + "/ws/keypad/");
        
        keyboardSocket.onopen = function () {
            const masteringSelect = document.getElementById("mastering");
            masteringSelect.focus();
        };
        
        keyboardSocket.onmessage = function (event) {
            const data = JSON.parse(event.data);
            const key = data.key;
        
            const masteringSelect = document.getElementById("mastering");
            const lowBtn = document.getElementById("lowMasterBtn");
            const highBtn = document.getElementById("highMasterBtn");
        
            const parameterwiseRadio = document.getElementById("parameterwise");
            const allParameterRadio = document.getElementById("all_parameter");
        
            switch (key) {
                case "F1":
                    document.getElementById("measureBtn").click();
                    break;
        
                case "UP":
                    if (document.activeElement !== masteringSelect) {
                        masteringSelect.focus(); // Force focus
                    }
                    masteringSelect.selectedIndex = Math.max(masteringSelect.selectedIndex - 1, 0);
                    masteringSelect.dispatchEvent(new Event("change"));
                    break;
        
                case "DWN":
                    if (document.activeElement !== masteringSelect) {
                        masteringSelect.focus(); // Force focus
                    }
                    masteringSelect.selectedIndex = Math.min(masteringSelect.selectedIndex + 1, masteringSelect.options.length - 1);
                    masteringSelect.dispatchEvent(new Event("change"));
                    break;
        
                case "LFT":
                    allParameterRadio.focus(); // Focus the "All Parameter" radio button
                    break;
        
                case "RGT":
                    masteringSelect.focus(); // Focus the dropdown again
                    break;
        
                case "ENT":
                    if (document.activeElement === allParameterRadio) {
                        allParameterRadio.checked = true;
                        allParameterRadio.dispatchEvent(new Event("change")); // Trigger associated logic
                    }  else {
                        // Default toggle behavior
                        if (toggleState) {
                            lowBtn.click();
                        } else {
                            highBtn.click();
                        }
                        toggleState = !toggleState;
                    }
                    break;
        
                case "C1":
                case "C2":
                case "C3":
                case "C4":
                case "C5":
                case "C6":
                    handleParameterSelection(key);
                    break;
            }
        };
        
        
        
        
        </script>    
        </body>
        </html>