{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="{% static 'fontawesome-free-6.7.2-web/css/all.min.css' %}">
    <script src="{% static 'jquery-jquery-f79d5f1/dist/jquery.min.js' %}"></script>


    <title>MEASUREMENT</title>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>

  
    <link rel="stylesheet" href="{% static 'css/measurement_va4.css'%}">

    <style>
  /* Switch wrapper */
  .switch {
  position: relative;
  display: inline-block;
  width: 5vw;
  height: 5vh;
  
}

/* Hide default checkbox */
.switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

/* Slider */
.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  transition: 0.4s;
  border-radius: 35%;
  border: 2px solid black;
}

/* Circle inside slider */
.slider::before {
  position: absolute;
  content: "";
  height: 3.5vh;
  width: 2vw;
  left: 4px;
  bottom: 4px;
  background-color: white;
  transition: 0.4s;
  border-radius: 50%;
}

/* When checkbox is checked */
.switch input:checked + .slider {
  background-color: #4caf50;
}

/* Move the circle */
.switch input:checked + .slider::before {
  transform: translateX(26px);
}

/* Optional: make it round */
.slider.round {
  border-radius: 34px;
}

.switch-container {
  position: fixed; /* Or 'absolute' if inside a specific parent */
  left: 2vw;
  z-index: 999;
  display: flex;
  align-items: center;
}



.num-pad {
    position: absolute;
    margin-left: 30%;
 
    bottom: 10%;         /* Adjust as needed */
    
    background: #ddd;
    padding: 10px;
    border-radius: 10px;
    text-align: center;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    height: 45vh;
    width: 25vw;
}

.num-btn {
    width: 30%;
    height: 15%;
    font-size: 3vw;
    margin: 5px;
    cursor: pointer;
    border: none;
    background: white;
    border-radius: 5px;
    font-weight: bold;
}

.num-btn:hover {
    background: lightgray;
}



        #output_values_container {
    height: 60vh;       /* Adjust as needed */
    width: 100%;
    overflow-y: auto;   /* Enables vertical scroll */
    position: relative; /* Required for scrollIntoView to behave correctly */
   
}

.Output_box {
    width: 100%;  /* Slightly reduced to fit inside the container */
    height: 35%;
    box-sizing: border-box;
    text-align: center;
    font-weight: bold;
    font-size: 9vw;
    margin-top: 7%;
    
}
.container_2nd{
   height: 100%;
   width: 30%;
   
}


.start_stop{
    height: 13%;
    width: 100%;
   
   
}

.button_cont{

    height: 100%;
    width: 100%;
  
}

#spc_btn,#report_btn{
    width: 15%;
    height: 60%;
    margin-left: 5%;
    text-align: center;
    font-weight: bold;
    font-size: 1.2vw;
    color: black;
    border: 2px solid black;
    font-family:'Courier New', Courier, monospace;
    background-color: rgb(240, 189, 95);
   
}

.focused-report-button {
  outline: 3px solid blue;
  border-radius: 6px;
  box-shadow: 0 0 5px blue;
}


.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.6);
  z-index: 9999;
  display: flex;
  align-items: center;
  justify-content: center;
}

.modal-box {
  background-color: yellow;
  padding: 20px 30px;
  border-radius: 10px;
  text-align: center;
  align-items: center;
  box-shadow: 0 0 10px #000000aa;
  height: 30%;
  width: 50%;
  font-size: 3vw;
  font-weight: bold;
}

.modal-box button {
  margin-top: 20px;
  padding: 8px 20px;
  font-size: 2.5vw;
  background-color: red;
  width: 40%;
  font-weight: bold;
}

#notificationOkBtn:focus {
    outline: 2px solid #007bff;
    background-color: red;
}


#probe-container {
    overflow-y: auto;
    display: flex;
    flex-wrap: wrap;         /* Wrap to next line if needed */
    align-items: center;
    gap: 5px;
    padding: 5px;
    height: 100%;
    box-sizing: border-box;
}

/* Compress all textareas */
#probe-container textarea {
    width: 5vw;              /* Smaller width */
    height: 2vw;           /* Optional: smaller height */
    font-size: 0.8vw;
    resize: none;
    padding: 2px;
    box-sizing: border-box;
    text-align: center;
}

.custom_table th{
    background-color: gray;
   
    font-size: 1.5vw;
    font-weight: bold;
}

.section {
    border: 1px solid black;
    display: flex;
    flex-direction: column;
    align-items: center;
    /* justify-content: center; */
    background-color: gray;
    width: 100%;
    height: 100%;
    padding: 5px;
    box-sizing: border-box;
}






.punchno-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: flex-end;
  align-items: flex-end;
  background-color: rgba(0, 0, 0, 0.5);
  z-index: 9999;
  pointer-events: none;
}

.punch_no-box {
  background-color: white;
  width: 75%;
  height: 15%;
  padding: 10px;
  margin-bottom: 5%;       /* Distance from bottom */
  margin-left: 5%;         /* Distance from the left */
  
  box-shadow: 0 0 15px rgba(0, 0, 0, 0.4);
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  pointer-events: all;
}

#punch_no{
    height: 100%;
    width: 100%;
    font-weight: bold;
    font-size: 4vw;
   background-color:yellow;
    color: black;
}

#punch_no_display{
    height: 90%;
    width: 25%;
    font-weight: bold;
    font-size: 2vw;
   background-color:lightgray;
    color: black;
}

#notification_bar{
    width: 55%;
    height: 95%;
    margin-left : 3px;
    background-color: orange;
    font-weight: bold;
    font-size: 1.8vw;
    color: black;
    text-align: center;
}


.enter_btn_container{
    background-color: white;
  width: 15%;
  height: 15%;
  padding: 10px;
  margin-bottom: 5%;       /* Distance from bottom */
  margin-right: 2%;        /* Distance from the left */
 
  box-shadow: 0 0 15px rgba(0, 0, 0, 0.4);
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  pointer-events: all;
}
#enter_btn_main{
    background-color: #0f0f;
    height: 90%;
    width: 90%;
   
    font-weight: bold;
    font-size: 3vw;
}







.modal-overlay_1 {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.6);
  z-index: 9999;
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: none; /* ðŸ‘ˆ Let clicks go through */
}

.modal-box_1 {
    pointer-events: auto;
  background-color: yellow;
  padding: 20px 30px;
  border-radius: 10px;
  text-align: center;
  align-items: center;
  box-shadow: 0 0 10px #000000aa;
  height: 35%;
  width: 50%;
  font-size: 3vw;
  font-weight: bold;
}

.modal-box_1 button {
  margin-top: 20px;
  padding: 8px 20px;
  font-size: 2.5vw;
  background-color: red;
  width: 40%;
  font-weight: bold;
}

#notificationOkBtn_1:focus {
    outline: 2px solid #007bff;
    background-color: red;
}






    </style>
    
    
</head>
<body>
    <div class="notify" style="display: none;"></div>

    <div id="loading_spinner" style="display: none;">
        <i class="fas fa-spinner fa-spin"></i> 
    </div>
    <div class="container-1">
        <div class="container-1-1">
            <button type="submit" id="menu_btn">
                <i class="fas fa-bars" id="menu_icon"></i>[F12]
            </button>
            <input type="text" id="date_time" readonly>
            <input type="text" id="operator" readonly>
            <input type="text" id="shift" class="shift-name">
            <input type="text" id="message" style="margin-left: 1%;" readonly>
            <button type="submit" id="exit_btn">
                <i class="fas fa-sign-out-alt" id="exit_icon"></i>
            </button>
        </div>
        <div class="container-1-2">
            <label for="part_model">PART MODEL:</label>
            <input type="text" id="part_model" readonly>

            <label for="part_no" style="margin-left: 1%;">PART NAME:</label>
            <input type="text" id="part_no" readonly>

            <label for="part_status" style="margin-left: 2%;">PART STATUS:</label>
            <input type="text" id="accept" readonly>
            <input type="text" id="rework" readonly>
            <input type="text" id="reject" readonly>
            <input type="text" id="total" readonly>
        </div>
        <div class="container-1-3">
            <input type="text" id="punch_no_display">
            <input type="text" id="notification_bar" readonly value="DO MEASUREMENT">
            <input type="text" id="overall_status" readonly>
        </div>

    </div>

<!--//////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->


<div class="container-2">
    <div class="container_2_1">
        <div class="section" id="sub_container_1">
            <input type="text" id="para_name1" class="input-box" value="CHANNEL-1" placeholder="Parameter Name" readonly/>
        

            <div class="label-row1">
                <label for="lsl_1">LSL</label>
                <label for="nominal_1">NOM</label>
                <label for="usl_1">USL</label>
            </div>
           
            <div class="input-row-top">
                <input type="text" id="lsl_1" class="input-box1-top" placeholder="LSL" readonly/>
                <input type="text" id="nominal_1" class="input-box1-top" placeholder="Nominal" readonly />
                <input type="text" id="usl_1" class="input-box1-top" placeholder="USL"  readonly/>
            </div>



            <input type="text" class="Output_box" id="Output_box1" readonly/>
        
            <div class="label-row">
                <label for="max1">MAX</label>
                <label for="min1">MIN</label>
                <label for="tir1">TIR</label>
            </div>
        
            <div class="input-row">
                <input type="text" id="max1" class="input-box1" readonly />
                <input type="text" id="min1" class="input-box1"  readonly/>
                <input type="text" id="tir1" class="input-box1" readonly />
            </div>
        </div>
        
        <div class="section"  id="sub_container_2">
            <input type="text" id="para_name2" class="input-box" value="CHANNEL-2"  placeholder="Parameter Name" readonly/>
        
            <div class="label-row1">
                <label for="lsl_2">LSL</label>
                <label for="nominal_2">NOM</label>
                <label for="usl_2">USL</label>
            </div>

            <div class="input-row-top">
                <input type="text" id="lsl_2" class="input-box1-top" placeholder="LSL" readonly/>
                <input type="text" id="nominal_2" class="input-box1-top" placeholder="Nominal" readonly/>
                <input type="text" id="usl_2" class="input-box1-top" placeholder="USL" readonly/>
            </div>



            <input type="text" class="Output_box"  id="Output_box2"  readonly/>
        
            <div class="label-row">
                <label for="max1">MAX</label>
                <label for="min1">MIN</label>
                <label for="tir1">TIR</label>
            </div>
        
            <div class="input-row">
                <input type="text" id="max2" class="input-box1" readonly />
                <input type="text" id="min2" class="input-box1" readonly />
                <input type="text" id="tir2" class="input-box1" readonly />
            </div>
        </div>
       
    </div>
   
   

<div class="container_2nd" >

<div class="output_container" id="output_values_container" style="overflow-y: auto;">
    <div>
        <table border="1" width="100%" class="custom_table"  width="100%">
            <thead>
                <tr>
                    <th></th>
                    <th>PARA NAME</th>
                    <th>CUR</th>
                    <th>MAX</th>
                    <th>MIN</th>
                    <th>TIR</th>

                </tr>
            </thead>
            <tbody id="table_body">
            
            </tbody>
        </table>
    </div>
</div>
<div class="start_stop"  >
    <div class="button_cont">
    <button id="rest-btn" class="toggle-btn" style="display: none;">START[F4]<br>STOP[F5]</button>
</div>
    <div  id="probe-container"  >
        <textarea id="probe-A"></textarea>
        <textarea id="probe-B"></textarea>
         <textarea id="probe-C"></textarea>
        <textarea id="probe-D"></textarea>
        <textarea id="probe-E"></textarea>
        <textarea id="probe-F"></textarea>
        <textarea id="probe-G"></textarea>
        <textarea id="probe-H"></textarea>

        <textarea id="probe-I"></textarea>
        <textarea id="probe-J"></textarea>
        <textarea id="probe-K"></textarea>
     </div>
    

</div>

</div>
    
</div>

<div id="punch_no_container"  class="punchno-overlay" style="display: none;">
    <div class="punch_no-box">
        <input type="text" id="punch_no" placeholder="ENTER THE PUNCH NO:">
        
    </div>

    <div class="enter_btn_container">
        <button id="enter_btn_main">ENTER</button>
    </div>
    
  </div>

    

<!--//////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

    <div class="container-3">
       
       
        <div class="container-3-2">
           

            <button type="submit" class="container-3-2-btn" id="master_btn">MASTERING[F1]</button>
            <button type="submit" class="container-3-2-btn" id="model_btn" onclick="showNextPartName()">MODEL[F2]</button>
            <button type="submit" class="container-3-2-btn" id="live_spc_btn">LIVE SPC[F3]</button>
            <button type="submit" class="container-3-2-btn" id="report_btn_main"  >REPORT[F6]</button>

            <button type="button" class="container-3-2-btn" id="spc_btn" style="display:none;">SPC[F7]</button>
            <button type="button" class="container-3-2-btn" id="report_btn" style="display:none;">REPORT[F8]</button>

           
        </div>

        <div id="punch_overwrite" class="center-notification" >
            <div id="punch_overwrite_container">
                <p id="error_message"></p>
                <p>Do you want to OVERWRITE</p>
                <button id="overwrite_cancel_button" onclick="punchOverwriteCancel()">CANCEL</button>
                <button id="overwrite_ok_button" onclick="punchOverwrite()" >OK</button>
            </div>
            <div id="punch_overwrite_credentials">
                <div class="switch-container">
                    <i class="fas fa-keyboard" style="margin-right: 10px;font-size: 5vh;color: maroon;"></i>
                    <label class="switch">
                      <input type="checkbox" id="toggle-switch">
                      <span class="slider round"></span>
                    </label>
                  </div>
               
                <label for="password_punch">PASSWORD:</label>
                <input type="text" id="password_punch" class="userpassinput"  ><br><br>
                <button id="punch_login" onclick="punchOverwriteLogin()">OK</button>
                </div>
        </div>


        </div>
    
        <input type="text" id="db_port" value="{{ comport_com_port }}" hidden>
        <input type="text" id="com_ports" value="{{ ports_string }}" hidden>
        <input type="text" id="baud_rate" value="{{ comport_baud_rate }}" hidden>
        <input type="text" id="parity" value="{{ comport_parity }}" hidden>
        <input type="text" id="stopbit" value="{{ comport_stopbit }}" hidden>
        <input type="text" id="databit" value="{{ comport_databit }}" hidden>
        <textarea id="serial-data-display" cols="50" rows="10" readonly hidden></textarea>  

            <!-- Custom Notification Modal -->
<div id="notificationModal" style="display: none;" class="modal-overlay">
    <div class="modal-box">
      <p id="notificationMessage">This is a custom notification.</p>
      <button id="notificationOkBtn">OK</button>
    </div>
  </div>

  <div id="notificationModal_1" style="display: none;" class="modal-overlay_1">
    <div class="modal-box_1">
      <p id="notificationMessage_1">This is a custom notification.</p>
      <button id="notificationOkBtn_1">OK</button>
    </div>
  </div>






  


 

   
<script>
    document.addEventListener("DOMContentLoaded", function () {
        const inputs = document.querySelectorAll("input");
        inputs.forEach(input => input.setAttribute("autocomplete", "off"));
    });
    

    const buttonIds = [
        "master_btn", "model_btn", "live_spc_btn", "report_btn_main",
        "spc_btn", "report_btn", "menu_btn", "exit_btn"
    ];

    function sendClearFlag() {
        fetch("/set-clear-flag/")
            .then(response => response.json())
            .then(data => {
                console.log("Flag sent:", data);
                // Optional: navigate or continue action after flag is set
            });
    }

    buttonIds.forEach(id => {
        const btn = document.getElementById(id);
        if (btn) {
            btn.addEventListener("click", sendClearFlag);
        }
    });
    
    
    
    
    let isNotificationOpen = false;
    
    function showNotifications(message) {
        isNotificationOpen = true;
        document.getElementById("notificationMessage").textContent = message;
        document.getElementById("notificationModal").style.display = "flex";
        document.getElementById("notificationOkBtn").focus();
    
        document.getElementById("notificationOkBtn").onclick = () => {
            document.getElementById("notificationModal").style.display = "none";
            isNotificationOpen = false;
            location.reload();
           
        };
    }
    
    
    function showNotifications1(message, partModel) {
        isNotificationOpen1 = true;
    
        document.getElementById("notificationMessage_1").textContent = message;
        document.getElementById("notificationModal_1").style.display = "flex";
        document.getElementById("notificationOkBtn_1").focus();
    
        document.getElementById("notificationOkBtn_1").onclick = () => {
            document.getElementById("notificationModal_1").style.display = "none";
            isNotificationOpen1 = false;
    
            // Redirect to master page with part_model in URL
            const encodedModel = encodeURIComponent(partModel);
            window.location.href = `/master/?part_model=${encodedModel}`;
        };
    }
    
    
    document.addEventListener('keydown', function (e) {
    if (e.key === "F5" || e.keyCode === 116) {
        e.preventDefault();
        console.log("F5 is disabled.");
    }
});


    
    
    
    
    document.addEventListener("DOMContentLoaded", function () {
                // Get the username passed from the backend
                let receivedUserName = "{{ username|safe }}";
                console.log('Your receivedUserName is:', receivedUserName);
    
                // Get the button element
                const menuButton = document.getElementById("menu_btn");
    
                // Add a click event listener to the button
                menuButton.addEventListener("click", function (event) {
                    // Check if the username is SAADMIN
                    if (receivedUserName === "SAADMIN") {
                        // Redirect to the comport page
                        window.location.href = "{% url 'comport' %}";
                    } else {
                        // Show an showNotifications message and prevent redirection
                        event.preventDefault();
                        showNotifications("You are not authorized to access this page.");
                    }
                });
            });
    
            document.addEventListener('keydown', function (event) {
        switch (event.key) {
            case 'F1':
                event.preventDefault();
                const masterBtn = document.getElementById('master_btn');
                if (
                    masterBtn &&
                    !masterBtn.disabled && 
                    masterBtn.style.filter !== "blur(2px)"
                ) {
                    masterBtn.click();
                }
                break;
    
            case 'F2':
                event.preventDefault();
                const modelBtn = document.getElementById('model_btn');
                if (
                    modelBtn &&
                    !modelBtn.disabled &&
                    modelBtn.style.filter !== "blur(2px)"
                ) {
                    modelBtn.click();
                }
                break;
    
            case 'F3':
                event.preventDefault();
                const spcBtn = document.getElementById('live_spc_btn');
                if (
                    spcBtn &&
                    !spcBtn.disabled &&
                    spcBtn.style.filter !== "blur(2px)"
                ) {
                    spcBtn.click();
                }
                break;
    
            case 'F12':
                event.preventDefault();
                const menuBtn = document.getElementById('menu_btn');
                if (
                    menuBtn &&
                    !menuBtn.disabled &&
                    menuBtn.style.filter !== "blur(2px)"
                ) {
                    menuBtn.click();
                }
                break;
        }
    });
    
    
    
    
        document.getElementById("exit_btn").addEventListener("click", function() {
            // Redirect to the measurement URL
            window.location.href = "{% url 'login' %}";
        });
        
    
    
    $(document).ready(function () {
        // Delay the execution by 2 seconds
        setTimeout(function () {
            // Get the input values
            var dateTime = $("#date_time").val(); // Example: 21/12/2024 6:53:57 PM
            console.log('Original value:', dateTime);
    
            // Convert the original format to Date object
            var dateParts = dateTime.split(' ');
            var date = dateParts[0].split('/');
            var time = dateParts[1].split(':');
            var ampm = dateParts[2];
            
            // Convert to 12-hour format (adjust time to 12-hour clock)
            var hours = parseInt(time[0]);
            if (ampm === 'PM' && hours < 12) {
                hours += 12; // Convert PM hours to 24-hour format
            }
            if (ampm === 'AM' && hours === 12) {
                hours = 0; // Convert 12 AM to 0 (midnight)
            }
    
            // Construct Date object with the corrected time
            var formattedDate = new Date(date[2], date[1] - 1, date[0], hours, time[1], time[2]);
    
            // Format the date to "yyyy/mm/dd hh:mm:ss AM/PM"
            var year = formattedDate.getFullYear();
            var month = (formattedDate.getMonth() + 1).toString().padStart(2, '0'); // Add leading zero if needed
            var day = formattedDate.getDate().toString().padStart(2, '0'); // Add leading zero if needed
            var hours12 = formattedDate.getHours() % 12 || 12; // 12-hour format
            var minutes = formattedDate.getMinutes().toString().padStart(2, '0');
            var seconds = formattedDate.getSeconds().toString().padStart(2, '0');
            var period = (formattedDate.getHours() >= 12) ? 'PM' : 'AM';
    
            var formattedDateTime = `${year}/${month}/${day} ${hours12}:${minutes}:${seconds} ${period}`;
            console.log('Formatted value to send:', formattedDateTime);
    
            var shift = $("#shift").val(); // Example: SHIFT-2
            var partModel = $("#part_model").val(); // Get the value of the part model input
    
    
            // Send AJAX GET request
            $.ajax({
                url: '/measurement_count/', // Replace this with your actual endpoint
                type: 'POST',
                data: { 
                    date: formattedDateTime, 
                    shift: shift,
                    part_model: partModel,
                },
                success: function (response) {
                    console.log("Data received successfully:");
                    console.log("Accept Last Occurrence:", response.accept_occurrence);
                    console.log("Reject Last Occurrence:", response.reject_occurrence);
                    console.log("Rework Last Occurrence:", response.rework_occurrence);
                    console.log("Total Occurrence:", response.total_occurrence);
    
                    // Display the values in the input fields
                    $('#accept').val(response.accept_occurrence);
                    $('#reject').val(response.reject_occurrence);
                    $('#rework').val(response.rework_occurrence);
                    $('#total').val(response.total_occurrence);
                },
                error: function (error) {
                    console.log("Error:", error);
                },
            });
        }, 2000); // Delay of 2000 milliseconds (2 seconds)
    });
    
    
    
    
    
    
    
    
    
    
    
     // Receive part model list and current part model from Django
     let receivedValue = "{{ part_model|safe }}";     // ['DIAMILER_1231', 'FUSO_12', 'sai', '111111']
        let receivedPartModel = "{{ part_name|safe }}";  // '111111'
    
        console.log('your part_model is:', receivedValue);
        console.log('your receivedPartModel is:', receivedPartModel);
    
        // Convert to clean array
        let partNames = receivedValue.replace(/[\[\]' ]/g, '').split(',');
        console.log("Clean partNames:", partNames);
    
        // Get current index based on receivedPartModel
        let currentIndex = partNames.indexOf(receivedPartModel);
        if (currentIndex === -1) currentIndex = 0;
    
        // Global alert variables
        let alertTimeoutId = null;
        let alertIntervalId = null;
        let activePartModel = null;
        let latestResponseData = null;
    
        function showNextPartName() {
            if (partNames.length > 0) {
                // Get next part circularly
                currentIndex = (currentIndex + 1) % partNames.length;
                const nextPartModel = partNames[currentIndex];
    
                // Update input
                document.getElementById('part_model').value = nextPartModel;
                document.getElementById("notificationModal_1").style.display = "none";
    
                // Backend logic
                sendPartModelToBackend(nextPartModel);
                sendPartModelForCount(nextPartModel);
    
                if (latestResponseData) {
                    handleIntervalAlerts(latestResponseData, nextPartModel);
                }
    
                // ðŸ”„ Reload page
                location.reload();
            } else {
                showNotifications("No part names available.");
            }
        }
    
        // On page load, send backend the current received part
        $(document).ready(function () {
            if (receivedPartModel) {
                $('#part_model').val(receivedPartModel);
                console.log("Initial partModel sent to backend:", receivedPartModel);
                sendPartModelToBackend(receivedPartModel);
            } else {
                console.warn("No receivedPartModel provided.");
            }
        });
    
        // Optional â€” don't override with index 0 blindly
        window.onload = function () {
            if (receivedPartModel) {
                document.getElementById('part_model').value = receivedPartModel;
            }
        };
    
    
    
    
    
            
    /////////////////////////////////////////////////////////////////
    
    
    
    document.addEventListener('DOMContentLoaded', function () {
        var savedPunchValue = localStorage.getItem('punchValue');
    
        if (savedPunchValue) {
            let punchTextarea = document.getElementById('punch_no');
            punchTextarea.value = savedPunchValue;
    
            // Clear localStorage value
            localStorage.removeItem('punchValue');
    
            // Set focus on the textarea
            punchTextarea.focus();
    
            // Automatically trigger Enter key after 2 seconds
            setTimeout(function () {
                let enterEvent = new KeyboardEvent('keydown', {
                    key: 'Enter',
                    code: 'Enter',
                    keyCode: 13,
                    which: 13,
                    bubbles: true
                });
    
                punchTextarea.dispatchEvent(enterEvent);
            }, 500); // 2000 milliseconds = 2 seconds
        }
    });
    
    
    
    
    
    function getCSRFToken() {
        const cookie = document.cookie.split('; ').find(row => row.startsWith('csrftoken='));
        return cookie ? cookie.split('=')[1] : '';
    }
    
    
    document.getElementById('enter_btn_main').addEventListener('click', function () {
        const modal = document.getElementById("notificationModal_1");
    
        // ðŸ›‘ Don't run if modal is active
        if (modal.style.display === "flex") {
            console.log("Modal is active. Ignoring Enter button click.");
            document.getElementById("notificationOkBtn_1").focus();
            return;
            
        }
    
        let punchTextarea = document.getElementById('punch_no');
    
        punchTextarea.focus();
    
        let enterEvent = new KeyboardEvent('keydown', {
            key: 'Enter',
            code: 'Enter',
            keyCode: 13,
            which: 13,
            bubbles: true
        });
    
        punchTextarea.dispatchEvent(enterEvent);
    });
    
    
    
    
    // Global object to store the response data for future use
    let responseData = {};
    
    
    // Global variable to store the total number of steps
    let totalSteps ;
    
    // Function to send the part model to the backend and store the response data
    function sendPartModelToBackend(partModel) {
        console.log("Sending updated partModel to backend:", partModel);
    
        $.ajax({
            url: '/measurement/', // Replace with your backend endpoint
            method: 'POST',
            data: { part_model: partModel },
            success: function (response) {
                console.log("part_name_value:", response.part_name_value);
                console.log("char_lock_value:", response.char_lock_value);
                console.log("char_lock_limit_value:", response.char_lock_limit_value);
                console.log("punch_no_value:", response.punch_no_value);
    
                    // ðŸ”” Display missing probes if any
        if (response.missing_probes && response.missing_probes.length > 0) {
            const missingList = response.missing_probes.join(", ");
            // showNotifications1("DO MASTERING FOR THIS PART MODE",partModel);
           
        } 
    
        const punchOverlay = document.getElementById('punch_no_container');
    
    if (response.punch_no_value === false) {
        console.log("FALSE CONDITION: punch_no_value is false");
    
        if (punchOverlay) {
            punchOverlay.style.display = 'flex';
    
            const punchBox = punchOverlay.querySelector('.punch_no-box');
            if (punchBox) {
                punchBox.style.display = 'none';
            }
        }
        
    
    } else if (response.punch_no_value === true) {
        console.log("TRUE CONDITION: punch_no_value is true");
    
        if (punchOverlay) {
            punchOverlay.style.display = 'flex';  // or 'block' depending on layout
        }
    
        const punchNoField = document.getElementById('punch_no');
        if (punchNoField) {
            punchNoField.focus(); // optional, if needed
        }
    
        const punchBox = punchOverlay.querySelector('.punch_no-box');
        if (punchBox) {
            punchBox.style.display = 'block'; // or 'flex' depending on your layout
        }
    }
    
    
    
                const restButton = document.getElementById('rest-btn'); // Get the button element
                const punchNoContainer = document.getElementById('punch_no_container');
                const punchNoDisplay = document.getElementById('punch_no_display');
    
                if (response.punch_no_value === true) {
                    const punchNoField = document.getElementById('punch_no');
                    if (punchNoContainer) punchNoContainer.style.display = 'flex';
                    if (punchNoField) {
                        punchNoField.disabled = false; // Ensure the field is enabled
                        punchNoField.style.filter = 'none'; // Remove blur effect
                        punchNoField.focus(); // Focus on the input field
    
                        if (restButton) {
                            restButton.disabled = true; // Disable the button
                            restButton.style.filter = 'blur(2px)'; // Apply blur effect
                        }
                        
                    }
                    // Remove any existing event listeners (optional, to avoid multiple bindings)
                    punchNoField.onkeydown = null;
    
                    // Listen for "Enter" key press
                    // Listen for "Enter" key press
                    punchNoField.addEventListener('keydown', function (event) {
                        if (event.key === 'Enter') {
                            event.preventDefault();
                            if (punchNoContainer) punchNoContainer.style.display = 'none';
                            document.activeElement.blur(); 
                            const inputValue = punchNoField.value;
                            const charLockValue = response.char_lock_value;
                            const charLockLimitValue = response.char_lock_limit_value;
                            const partModel = document.getElementById('part_model').value; // Get part_model
    
                            
    
                            // Validation checks for input value
                            if (charLockValue && !inputValue.startsWith(charLockValue)){
                                showNotifications("INVALID PUNCH NUMBER");
                                
                                punchNoField.value = '';
                                punchNoField.focus();
    
                                return;
                            }
    
                            const expectedLength = Number(charLockLimitValue);
                            if (expectedLength > 0 && inputValue.length !== expectedLength) {
                                showNotifications("INVALID PUNCH NUMBER");
                                
                                
    
                                punchNoField.value = '';
                                punchNoField.focus();
    
                                return;
                            }
    
    
                             // âœ… Display the value in #punch_no_display
                             if (punchNoDisplay) {
                                    punchNoDisplay.value = inputValue;
                                }
    
                                // Hide the container and blur the input
                                if (punchNoContainer) punchNoContainer.style.display = 'none';
                                document.activeElement.blur();
    
                            // Re-enable and remove blur effect from the rest button
                            if (restButton) {
                                restButton.disabled = false; // Enable the button
                                restButton.style.filter = 'none'; // Remove blur effect
                            }
    
                            
    
                            // Step 1: Send POST request to check if the punch number exists
                            fetch('/delete_measure_data/', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-CSRFToken': getCSRFToken()
                                },
                                body: JSON.stringify({ input_value: inputValue, part_model: partModel }) // Send part_model and comp_sr_no
                            })
                            .then(response => response.json()) // Ensure the response is JSON
                            .then(data => {
                                if (data.status === 'exists') {
                                   
                                    // Step 2: Show overwrite confirmation popup
                                    document.getElementById('error_message').innerText = data.message;
                                    document.getElementById('punch_overwrite').style.display = 'block';
    
    
    
                                    // Handle OK button click
                                    document.getElementById('overwrite_ok_button').onclick = function () {
                                        document.getElementById('punch_overwrite_container').style.display = 'none';
                                        // Show credentials input field
                                        document.getElementById('punch_overwrite_credentials').style.display = 'block';
                                    };
    
                                    // Handle Cancel button click
                                    document.getElementById('overwrite_cancel_button').onclick = function () {
                                        document.getElementById('punch_overwrite').style.display = 'none';
                                        location.reload();
                                    };
    
                                    // Step 3: Handle deletion with credentials
                                    document.getElementById('punch_login').onclick = function () {
                                        // const userId = document.getElementById('userid_punch').value; // Get user ID from input field
                                        const password = document.getElementById('password_punch').value; // Get password from input field
    
                                        // Validate credentials before posting
                                        if ( password !== 'admin') {
                                            showNotifications('Invalid credentials. Please check username and password.');
                                            return;
                                        }
                                        localStorage.setItem('punchValue', inputValue);
                                        // Send delete request with credentials
                                        fetch('/delete_measure_data/', {
                                            method: 'POST',
                                            headers: {
                                                'Content-Type': 'application/json',
                                                'X-CSRFToken': getCSRFToken()
                                            },
                                            body: JSON.stringify({
                                                input_value: inputValue,
                                                part_model: partModel,
                                                password: password
                                            })
                                        })
                                        .then(response => response.json())
                                        .then(deleteData => {
                                            showNotifications(deleteData.message); // Show success/error message
                                          
                                            location.reload();
                                            if (deleteData.success) {
                                                document.getElementById('punch_overwrite').style.display = 'none';
                                                $('#punch_overwrite').hide();
                                                
                                            }
                                        })
                                        .catch(error => {
                                            console.error('Error:', error);
                                            showNotifications('Failed to delete punch number.');
                                        });
                                    };
                                }
                                 else { 
                                    
                                    setTimeout(() => {
                                        const restBtn = document.getElementById('rest-btn');
                                        const autoManArray = response.auto_man_array || [];
    
                                        console.log("autoManArray[0]:", autoManArray[0]);
    
                                        if (restBtn) {
                                            restBtn.style.display = 'block';
    
                                            if (autoManArray[0] === true) {
                                                console.log("Disabling restBtn due to autoManArray[0] === true");
                                                restBtn.disabled = true;
                                                restBtn.style.filter = 'blur(3px)';
                                                restBtn.style.pointerEvents = 'none';
                                            } else {
                                                console.log("Enabling restBtn because autoManArray[0] !== true");
                                                restBtn.disabled = false;
                                                restBtn.style.filter = '';
                                                restBtn.style.pointerEvents = '';
                                            }
                                        }
                                    }, 100); // Delay for 100ms to allow DOM to render fully
                                    let notificationBar = document.getElementById('notification_bar');
                                    notificationBar.value = `DO MEASUREMENT FOR STEP ${currentStep} `;
    
                                        updateUI(responseData);
    
                                        // document.getElementById('rest-btn').style.display = 'none';
    
                                    
    
                                        // allowFunctionKeys = true; // Now enable F4 and F5
                                        button.disabled = false;
                                        button.style.filter = "";
                                        button.style.pointerEvents = "";
    
                                        // Disable F-key buttons during measurement
                                        const functionButtons = ["master_btn", "model_btn", "live_spc_btn", "report_btn_main", "menu_btn"];
                                        functionButtons.forEach(id => {
                                            const btn = document.getElementById(id);
                                            if (btn) {
                                                btn.disabled = true;
                                                btn.style.filter = "blur(2px)";
                                                btn.style.pointerEvents = "none";
                                            }
                                        });
                                    // âœ… Clear only measurement values
                                    parameterNames.forEach((name, index) => {
                                        const i = index + 1;
                                        const curInput = document.getElementById(`cur_${i}`);
                                        const maxInput = document.getElementById(`max_${i}`);
                                        const minInput = document.getElementById(`min_${i}`);
                                        const tirInput = document.getElementById(`tir_${i}`);
    
                                        if (curInput) {
                                    curInput.value = "";
                                    curInput.style.backgroundColor = ""; // âœ… Clear color
                                }
                                        if (maxInput) maxInput.value = "";
                                        if (minInput) minInput.value = "";
                                        if (tirInput) tirInput.value = "";
                                    });
                                
    
                                handleKeyPress(event); // For F4/F5 handling
    
    
                                }
                            })
                            .catch(error => {
                                console.error('Error:', error);
                                showNotifications('Failed to process punch number.');
                            });
                            
                        }
                    });
    
    
                    
    
    
                } 
                else {
                    // Keep the button disabled and blurred if 'punch_no_value' is false
                   // $('#rest-btn').prop('disabled', false).css('filter', 'none');
                    const punchNoField = document.getElementById('punch_no');
                    if (punchNoField) {
                        punchNoField.disabled = true; // Disable the field
                        punchNoField.style.filter = 'blur(2px)'; // Apply blur effect
                    }
    
                    if (restButton) {
                        restButton.disabled = false;
                        restButton.style.filter = 'none';
                    }
                }
    
    
    
    
                
    
                // Display the 'part_name_value' in the input field with id 'part_no'
                $('#part_no').val(response.part_name_value);
    
                // Update the global responseData object
                responseData = {
                    partNameValue: response.part_name_value,
                    charLockValue: response.char_lock_value,
                    charLockLimitValue: response.char_lock_limit_value,
                    punchNoValue: response.punch_no_value,
                    parameterValues: response.parameter_values,
                    parameterNameArray: response.parameter_name_array,
                    channelNoArray: response.channel_no_array,
                    lowMasterArray: response.low_master_array,
                    highMasterArray: response.high_master_array,
                    nominalArray: response.nominal_array,
                    lslArray: response.lsl_array,
                    uslArray: response.usl_array,
                    ltlArray: response.ltl_array,
                    utlArray: response.utl_array,
                    stepNoArray: response.step_no_array,
                    autoManArray: response.auto_man_array,
                    timerArray: response.timer_array,
                    digitsArray: response.digits_array,
                    singleDoubleArray : response.single_double_array,
                    parameter_factor_values:response.parameter_factor_values,
                    interval_settings_json:response.interval_settings_json,
                    last_stored_dates:response.last_stored_dates,
                    fixed_channel_array:response.fixed_channel_array,

                    clear_flag_value:response.clear_flag_value,
                    
                };
                setTimeout(() => {
        handleIntervalAlerts(responseData);
    }, 500); // 3000 ms = 3 seconds
    
    
    
                console.log("Step No:", response.step_no_array);
                console.log(" response.parameter_name_array No:", response.parameter_name_array);
    
                
                console.log("Response Data:", responseData);
    
    
    
    
    
    
                const fixed_channel_array = responseData.fixed_channel_array;
    const probeDataArray = responseData.parameterValues;
    const parameter_factor_values = responseData.parameter_factor_values;
    
    // Step 1: Build map of first index per fixed_channel
    const firstIndexMap = {};
    fixed_channel_array.forEach((channel, index) => {
        if (firstIndexMap[channel] === undefined) {
            firstIndexMap[channel] = index;
        }
    });
    console.log("First Index of Each Channel:", firstIndexMap);
    
    // Step 2: Loop through all 8 gauges (1 to 8)
    const displayDataList = [];
    const totalGauges = 2;
    
    for (let gaugeIndex = 1; gaugeIndex <= totalGauges; gaugeIndex++) {
        const container = $('#sub_container_' + gaugeIndex);
        const paraName = $('#para_name' + gaugeIndex);
        const outputBox = container.find('.Output_box');
    
        // âœ… Always set the parameter name
        paraName.val(`CHANNEL-${gaugeIndex}`);
    
        const index = firstIndexMap[gaugeIndex]; // gaugeIndex = fixed_channel number
    
        if (index === undefined) {
            // ðŸ”´ Channel data not found â€” leave the rest empty, but DO NOT clear or blur
            console.log(`Gauge ${gaugeIndex}: No data for fixed_channel ${gaugeIndex}`);
            continue;
        }
    
        // âœ… Fixed channel is available â†’ Fill data
        const lowMaster = responseData.lowMasterArray[index];
        const highMaster = responseData.highMasterArray[index];
        const lsl = responseData.lslArray[index];
        const nominal = responseData.nominalArray[index];
        const usl = responseData.uslArray[index];
        const ltl = responseData.ltlArray[index];
        const utl = responseData.utlArray[index];
        const digits = responseData.digitsArray[index];
        const single_double = responseData.singleDoubleArray[index];
        const parameterName = responseData.parameterNameArray[index];
        const probeNumber = responseData.channelNoArray[index];
        const autoMan = false;
        const timer = 0;
        const stepNo = 1;

        const parameter_factor_values = 0;
    
        const probeData = probeDataArray.find(p => p.probe_number == probeNumber) || {};
    
        const e_value = probeData.e || 0;
        const d_value = probeData.d || 0;
        const o1_value = probeData.o1 || 0;
        const a1_value = probeData.a1 || 0;
        const b_value = probeData.b || 0;
        const b1_value = probeData.b1 || 0;
    
        $('#lsl_' + gaugeIndex).val(`${lsl}`).css('color', 'purple');
        $('#nominal_' + gaugeIndex).val(`${nominal}`);
        $('#usl_' + gaugeIndex).val(`${usl}`).css('color', 'purple');
        container.css({ 'filter': 'none', 'pointer-events': 'auto', 'opacity': '1' });
    
        displayDataList.push({
            parameterName, probeNumber, lowMaster, highMaster, lsl, usl, ltl, utl,
            stepNo, autoMan, timer, digits, e_value, d_value, o1_value,
            gaugeIndex, a1_value, parameter_factor_values, single_double,
            b_value, b1_value
        });
    }
    
                    // âœ… Step 3: Call displaySerialData() for each item AFTER loop â€” simultaneously
                    displayDataList.forEach(data => {
                        displaySerialData(
                            data.parameterName, data.probeNumber, data.lowMaster, data.highMaster,
                            data.lsl, data.usl, data.ltl, data.utl,
                            data.stepNo, data.autoMan, data.timer, data.digits,
                            data.e_value, data.d_value, data.o1_value,
                            data.gaugeIndex, data.a1_value, data.parameter_factor_values,
                            data.single_double, data.b_value, data.b1_value
                        );
                    });
    
    
    
    
                    const lsl = response.lsl_array;
                    const usl = response.usl_array;
                    const ltl = response.ltl_array;
                    const utl = response.utl_array;
                                    
                    const measurement_dataArray = response.measurement_data;
                    console.log("measurement_dataArray", measurement_dataArray);
    
                    const tableBody = document.getElementById("table_body");
const parameterNames = response.parameter_name_array;
const clearFlag = response.clear_flag_value; // boolean: true or false

// Clear existing rows
tableBody.innerHTML = "";

parameterNames.forEach((name, index) => {
    const i = index + 1;

    const row = document.createElement("tr");
    row.id = `row_${i}`;
    row.style.display = "";

    // Get limit values
    const lslVal = parseFloat(lsl[index]);
    const uslVal = parseFloat(usl[index]);
    const ltlVal = parseFloat(ltl[index]);
    const utlVal = parseFloat(utl[index]);

    // Find corresponding measurement data by parameter name
    const matchingData = measurement_dataArray.find(data => data.parameter_name === name);

    // If clear_flag is true, set all values to empty
    const output = clearFlag ? "" : (matchingData ? parseFloat(matchingData.output) : "");
    const max_value = clearFlag ? "" : (matchingData ? matchingData.max_value : "");
    const min_value = clearFlag ? "" : (matchingData ? matchingData.min_value : "");
    const tir_value = clearFlag ? "" : (matchingData ? matchingData.tir_value : "");

    // Create the row
    row.innerHTML = `
        <td style="font-size: 0.9vw;">${i}</td>
        <td><input type="text" id="param_${i}" value="${name}" style="font-size: 0.9vw;"></td>
        <td><input type="text" id="cur_${i}" value="${output}" style="font-size: 0.8vw;"></td>
        <td><input type="text" id="max_${i}" value="${max_value}" style="font-size: 0.8vw;"></td>
        <td><input type="text" id="min_${i}" value="${min_value}" style="font-size: 0.8vw;"></td>
        <td><input type="text" id="tir_${i}" value="${tir_value}" style="font-size: 0.8vw;"></td>
    `;

    tableBody.appendChild(row);

    // ðŸŒˆ Apply background color logic only if values are shown
    if (!clearFlag) {
        const outputBox = document.getElementById(`cur_${i}`);
        if (!isNaN(output) && outputBox) {
            if (output < ltlVal) {
                outputBox.style.backgroundColor = "red";
            } else if (output >= ltlVal && output < lslVal) {
                outputBox.style.backgroundColor = "yellow";
            } else if (output >= lslVal && output <= uslVal) {
                outputBox.style.backgroundColor = "#00ff00"; // Green
            } else if (output > uslVal && output <= utlVal) {
                outputBox.style.backgroundColor = "yellow";
            } else if (output > utlVal) {
                outputBox.style.backgroundColor = "red";
            }
        }
    }
});

    
    
    
    
    
    
    
    
                // Update the global totalSteps variable
                const stepNo = response.step_no_array;
                totalSteps = Math.max(...stepNo); // Find the largest step number
                console.log("Number of Steps:", totalSteps);
    
                // Log the totalSteps after it has been updated
                console.log("Global totalSteps (after update):", totalSteps);
    
                // Iterate through the parameter values and display all fields for each parameter
                const parameterValues = response.parameter_values;
    
                console.log("parameterValues",parameterValues)
              
    
    if (response.punch_no_value === false) {
    
    
        const punchOverlay = document.getElementById('punch_no_container');
    punchOverlay.style.display = 'flex';
    
    const punchBox = punchOverlay.querySelector('.punch_no-box');
    if (punchBox) {
        punchBox.style.display = 'none';
    }
    
                // Enable function keys after pressing Enter
        document.addEventListener('keydown', function (event) {
            if (event.key === 'Enter') {
                document.getElementById('punch_no_container').style.display = 'none';
    
                let notificationBar = document.getElementById('notification_bar');
    notificationBar.value = `DO MEASUREMENT FOR STEP ${currentStep} `;
    
                  
                setTimeout(() => {
        const restBtn = document.getElementById('rest-btn');
        const autoManArray = response.auto_man_array || [];
    
        console.log("autoManArray[0]:", autoManArray[0]);
    
        if (restBtn) {
            restBtn.style.display = 'block';
    
            if (autoManArray[0] === true) {
                console.log("Disabling restBtn due to autoManArray[0] === true");
                restBtn.disabled = true;
                restBtn.style.filter = 'blur(3px)';
                restBtn.style.pointerEvents = 'none';
            } else {
                console.log("Enabling restBtn because autoManArray[0] !== true");
                restBtn.disabled = false;
                restBtn.style.filter = '';
                restBtn.style.pointerEvents = '';
            }
        }
    }, 100); // Delay for 100ms to allow DOM to render fully
    
                
        updateUI(responseData);
       
    
    
    
                
              
    
                // allowFunctionKeys = true; // Now enable F4 and F5
    
    
    
                button.disabled = false;
                button.style.filter = "";
                button.style.pointerEvents = "";
    
                // Disable F-key buttons during measurement
                const functionButtons = ["master_btn", "model_btn", "live_spc_btn", "report_btn_main", "menu_btn"];
                functionButtons.forEach(id => {
                    const btn = document.getElementById(id);
                    if (btn) {
                        btn.disabled = true;
                        btn.style.filter = "blur(2px)";
                        btn.style.pointerEvents = "none";
                    }
                });
             // âœ… Clear only measurement values
             parameterNames.forEach((name, index) => {
                const i = index + 1;
                const curInput = document.getElementById(`cur_${i}`);
                const maxInput = document.getElementById(`max_${i}`);
                const minInput = document.getElementById(`min_${i}`);
                const tirInput = document.getElementById(`tir_${i}`);
    
                if (curInput) {
            curInput.value = "";
            curInput.style.backgroundColor = ""; // âœ… Clear color
        }
                if (maxInput) maxInput.value = "";
                if (minInput) minInput.value = "";
                if (tirInput) tirInput.value = "";
            });
        }
    
        handleKeyPress(event); // For F4/F5 handling
    });
                }
    
            },
            error: function (xhr, status, error) {
                console.error('Error:', error);
            }
        });
    }
    
    
    
    
    function handleIntervalAlerts(responseData, partModel) {
        const startDate = new Date(responseData.last_stored_dates);
        let intervalSettings = JSON.parse(responseData.interval_settings_json) || [];
    
        // âœ… Filter out intervals with 0 hours and 0 minutes
        intervalSettings = intervalSettings.filter(setting => setting.hour !== 0 || setting.minute !== 0);
        if (intervalSettings.length === 0) {
            console.log("â³ No valid interval settings found. Skipping alerts.");
            return;
        }
    
        document.getElementById("notificationModal_1").style.display = "none";
    
        if (alertTimeoutId) {
            clearTimeout(alertTimeoutId);
            alertTimeoutId = null;
        }
        if (alertIntervalId) {
            clearInterval(alertIntervalId);
            alertIntervalId = null;
        }
    
        activePartModel = partModel;
    
        intervalSettings.forEach(setting => {
            const hours = setting.hour;
            const minutes = setting.minute;
            const interval = (hours * 60 + minutes) * 60 * 1000;
    
            const firstAlertTime = new Date(startDate.getTime() + interval);
            const now = new Date();
            const timeUntilFirstAlert = firstAlertTime - now;
    
            if (timeUntilFirstAlert > 0) {
                alertTimeoutId = setTimeout(() => {
                    if (activePartModel === partModel) {
                        showNotifications1("DO MASTERING !", partModel);
                    }
    
                    alertIntervalId = setInterval(() => {
                        if (activePartModel === partModel) {
                            showNotifications1("DO MASTERING !", partModel);
                        }
                    }, interval);
                }, timeUntilFirstAlert);
            } else {
                if (activePartModel === partModel) {
                    showNotifications1("DO MASTERING !", partModel);
                }
    
                alertIntervalId = setInterval(() => {
                    if (activePartModel === partModel) {
                        showNotifications1("DO MASTERING !", partModel);
                    }
                }, interval);
            }
        });
    }
    
    
    
    
    
    
    let currentStep = 1; // Ensure currentStep is an integer
    
    // Function to update UI based on current step
    function updateUI(responseData) {
        if (!responseData || typeof responseData !== 'object') {
            console.error("Error: responseData is undefined or not an object", responseData);
            return;
        }
    
        fixed_channel_array = responseData.fixed_channel_array;
        console.log("fixed_channel_array hhhhhhhhhhhhhhhhhhhhhhhhh",fixed_channel_array)
    
        if (!responseData.stepNoArray) {
            console.error("Error: stepNoArray is missing in responseData", responseData);
            return;
        }
    
        let indices = responseData.stepNoArray
            .map((step, index) => parseInt(step) === currentStep ? index : -1)
            .filter(index => index !== -1);
    
        console.log("Matching Indices:", indices);
    
        let totalGauges = 8; // Total number of available gauges
    
        // Loop through all containers to clear values & apply blur effect initially
        for (let i = 1; i <= totalGauges; i++) {
            let container = $('#sub_container_' + i);
            
            // Clear input fields inside the container
            container.find('input, textarea').val('');
            
            // Explicitly clear Output_box
            container.find('.Output_box').val('');
            
            // Apply blur effect to all initially
            container.css({ 'filter': 'blur(5px)', 'pointer-events': 'none', 'opacity': '0.5' });
        }
    
        indices.forEach((index) => {
        let gaugeIndex = fixed_channel_array[index]; // Get the actual channel like '1', '3', etc.
        console.log(`Updating Gauge ${gaugeIndex} with index ${index}`);
    
            // Extract values properly
            const parameterName = responseData.parameterNameArray[index];
            const probeNumber = responseData.channelNoArray[index];
            const lowMaster = responseData.lowMasterArray[index];
            const highMaster = responseData.highMasterArray[index];
            const lsl = responseData.lslArray[index];
            const usl = responseData.uslArray[index];
            const ltl = responseData.ltlArray[index];
            const utl = responseData.utlArray[index];
            const stepNo = responseData.stepNoArray[index];
            const autoMan = responseData.autoManArray[index];
            const timer = responseData.timerArray[index];
            const digits = responseData.digitsArray[index];
            const single_double = responseData.singleDoubleArray[index]; 
            const parameter_factor_values = responseData.parameter_factor_values;
    
            let e_value = 0, d_value = 0, o1_value = 0, a1_value = 0 ,b_value = 0,b1_value = 0;
            let probeData = responseData.parameterValues.find(
            item => item.fixed_channel === String(gaugeIndex)
        );
    console.log("probeData ssssssssssssssssssssssssssssss",probeData)
    
    
    
    
    
    
    
            if (probeData) {
                e_value = probeData.e || 0;
                d_value = probeData.d || 0;
                o1_value = probeData.o1 || 0;
                a1_value = probeData.a1 || 0;
                b_value = probeData.b || 0;
                b1_value = probeData.b1 || 0;
                console.log(`Probe Number: ${probeData.probe_number}, E: ${e_value}, D: ${d_value}, O1: ${o1_value} , B:${b_value},B1:${b1_value}`);
            } else {
                console.log("No Probe Data Found for Channel:", probeNumber);
            }
    
            // Update UI Elements
            $('#para_name' + gaugeIndex).val(parameterName);
            $('#lsl_' + gaugeIndex).val(` ${lsl}`).css('color', 'purple');
            $('#nominal_' + gaugeIndex).val(` ${responseData.nominalArray[index]}`);
            $('#usl_' + gaugeIndex).val(` ${usl}`).css('color', 'purple');
    
            // Ensure displaySerialData is called correctly
            if (stepNo === currentStep.toString()) {
                displaySerialData(
                    parameterName, probeNumber, lowMaster, highMaster, lsl, usl, ltl, utl, 
                    stepNo, autoMan, timer, digits, e_value, d_value, o1_value, gaugeIndex, a1_value,parameter_factor_values,single_double,b_value,b1_value
                );
            }
    
            // Remove blur effect from used containers
            $('#sub_container_' + gaugeIndex).css({ 'filter': 'none', 'pointer-events': 'auto', 'opacity': '1' });
    
            // Handle textarea input dynamically
            const textareaId = mapProbeToTextareaId(probeNumber);
            console.log("textareaId:", textareaId);
    
            const textarea = document.getElementById(textareaId);
            if (textarea) {
                // Remove existing event listener to avoid multiple bindings
                textarea.removeEventListener('input', handleTextareaInput);
                textarea.addEventListener('input', handleTextareaInput);
    
                function handleTextareaInput() {
                    let textareaValue = (textarea.value.trim() === '' || isNaN(parseFloat(textarea.value))) ? 0 : parseFloat(textarea.value);
    
                    if (stepNo === currentStep.toString()) {
                        displaySerialData(
                            parameterName, probeNumber, lowMaster, highMaster, lsl, usl, ltl, utl, 
                            stepNo, autoMan, timer, digits, e_value, d_value, o1_value, gaugeIndex, a1_value,parameter_factor_values,single_double,b_value,b1_value
                        );
                    }
                }
            }
        });
    }
    
    
    
    
    
    
    
    
    // Global variables
    let displayOutputs = []; // Stores displayOutput values for all steps
    let isStart = true; // Tracks the current state of the button
    let updateInterval = null; // Stores interval reference
    let notificationBar;
    let button;
    
    // Initialize elements
    function initElements() {
        button = document.getElementById('rest-btn');
        notificationBar = document.getElementById('notification_bar');
    
        if (!button || !notificationBar) {
            console.error("Required elements not found!");
            return;
        }
    
        button.addEventListener('click', handleAction);
        document.addEventListener('keydown', handleKeyPress);
        
        updateUI(); // Initialize UI for step 1
    }
    
    // Handle button click
    function handleAction() {
        if (isStart) {
            startAction();
        } else {
            stopAction();
        }
        isStart = !isStart; // Toggle the state
    }
    
    // // Start measurement
    // function startAction() {
    //     console.log(`Start action triggered for Step ${currentStep}!`);
    //     notificationBar.value = `MEASUREMENT IS STARTING FOR STEP ${currentStep} `;
    //     updateButton(` STOP[F5]- Step ${currentStep}`, 'stop-btn');
    
        
    
    //     let indices = getStepIndices();
    //     console.log("indices iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii",indices)
    //     updateInterval = setInterval(() => {
    //     console.log("======= Starting new interval =======");
    //     console.log("ðŸ” Full gaugeOutputs:", JSON.stringify(gaugeOutputs, null, 2));
    
    //     Object.entries(gaugeOutputs).forEach(([groupKey, gaugeGroup]) => {
    //         console.log(`ðŸ“¦ Group Key: ${groupKey}, Gauge Group:`, gaugeGroup);
    
    //         Object.entries(gaugeGroup).forEach(([key1, value1]) => {
    //             console.log(`ðŸ”‘ Intermediate Key: ${key1}, Value:`, value1);
    
    //             // If value1 is a nested object (like {3: 12.47})
    //             if (typeof value1 === 'object' && value1 !== null) {
    //                 Object.entries(value1).forEach(([gaugeIndexStr, val]) => {
    //                     let gaugeIndex = parseInt(gaugeIndexStr);
    //                     console.log(`âœ… Calling updateMaxMinTir for gaugeIndex: ${gaugeIndex}`);
    //                     updateMaxMinTir(gaugeIndex);
    //                 });
    //             } else {
    //                 // Just in case it's not an object
    //                 let gaugeIndex = parseInt(key1);
    //                 console.log(`âœ… Calling updateMaxMinTir for gaugeIndex: ${gaugeIndex}`);
    //                 updateMaxMinTir(gaugeIndex);
    //             }
    //         });
    //     });
    // }, 100);
    
    // }
    
    
    function startAction() {
        if (autoStartedSteps.has(currentStep)) return;
        autoStartedSteps.add(currentStep);
    
        console.log(`Start action triggered for Step ${currentStep}!`);
        notificationBar.value = `MEASUREMENT IS STARTING FOR STEP ${currentStep} `;
        updateButton(` STOP[F5]- Step ${currentStep}`, 'stop-btn');
    
        let indices = getStepIndices();
        console.log("indices iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii", indices);
        updateInterval = setInterval(() => {
            console.log("======= Starting new interval =======");
            console.log("ðŸ” Full gaugeOutputs:", JSON.stringify(gaugeOutputs, null, 2));
    
            Object.entries(gaugeOutputs).forEach(([groupKey, gaugeGroup]) => {
                Object.entries(gaugeGroup).forEach(([key1, value1]) => {
                    if (typeof value1 === 'object' && value1 !== null) {
                        Object.entries(value1).forEach(([gaugeIndexStr, val]) => {
                            let gaugeIndex = parseInt(gaugeIndexStr);
                            console.log(`âœ… Calling updateMaxMinTir for gaugeIndex: ${gaugeIndex}`);
                            updateMaxMinTir(gaugeIndex);
                        });
                    } else {
                        let gaugeIndex = parseInt(key1);
                        console.log(`âœ… Calling updateMaxMinTir for gaugeIndex: ${gaugeIndex}`);
                        updateMaxMinTir(gaugeIndex);
                    }
                });
            });
        }, 100);
    }
    
    
    function stopAction() {
        console.log(`Stop action triggered for Step ${currentStep}!`);
        notificationBar.value = `MEASUREMENT IS COMPLETED FOR STEP ${currentStep} `;
        updateButton(`START[F4] - Step ${currentStep + 1}`, 'start-btn');
        clearInterval(updateInterval);
    
        const { matchedIndices, matchedGauges } = getStepIndices();  // Destructure both
        const container = matchedIndices.length;
        const parameterNames = matchedIndices.map(index => responseData.parameterNameArray[index]);
    
        updateTableValues(currentStep, matchedIndices, parameterNames, container,matchedGauges); // Use matchedIndices here
        clearMaxMinTirFields(matchedGauges); // Use gauge channel numbers here
        checkFinalStep();
        updateUI(responseData);
    }
    
    function getStepIndices() {
        const fixed_channel_array = responseData.fixed_channel_array;
    
        const matchedIndices = [];
        const matchedGauges = [];
    
        responseData.stepNoArray.forEach((step, index) => {
            if (parseInt(step) === currentStep) {
                matchedIndices.push(index);
                matchedGauges.push(fixed_channel_array[index]);
            }
        });
    
        console.log(`Matched Indices for Step ${currentStep}:`, matchedIndices); // [0, 1]
        console.log(`Matched Gauge Channels for Step ${currentStep}:`, matchedGauges); // ['1', '3']
    
        return {
            matchedIndices,   // array of raw indices like [0, 1]
            matchedGauges     // array of corresponding channels like ['1', '3']
        };
    }
    
    
    // Clear min/max/tir input fields
    function clearMaxMinTirFields(indices) {
        indices.forEach((index, displayIndex) => {
            let gaugeIndex = displayIndex + 1;
            ['max', 'min', 'tir'].forEach(field => {
                let input = document.getElementById(`${field}${gaugeIndex}`);
                if (input) input.value = "";
            });
        });
    }
    
    // Check if it's the final step
    function checkFinalStep() {
        if (currentStep < totalSteps) {
            currentStep++;
        } else {
            console.log("All steps completed!");
            
            notificationBar.value = "YOU HAVE COMPLETED THE MEASUREMENT FOR THIS JOB. DO THE NEXT JOB.";
            updateButton("START[F4]", "start-btn");
            finalizeUI();
            checkOverallStatus();
            collectFinalData();
    
    
            // Re-enable F-key buttons
    const functionButtons = ["master_btn", "model_btn", "live_spc_btn", "report_btn_main", "exit_btn", "menu_btn"];
    functionButtons.forEach(id => {
        const btn = document.getElementById(id);
        if (btn) {
            btn.disabled = false;
            btn.style.filter = "none";
            btn.style.pointerEvents = "auto";
        }
    });
    
        }
    }
    
    // Check and update overall status based on row colors
    function checkOverallStatus() {
        console.log("Final Step Reached: Checking All Rows");
    
        let isRed = false;
        let isYellow = false;
        let overallStatus = document.getElementById("overall_status");
    
        for (let i = 1; i <= 21; i++) {
            let curInput = document.getElementById(`cur_${i}`);
    
            if (curInput) {
                let bgColor = window.getComputedStyle(curInput).backgroundColor;
                console.log(`Row ${i} Background Color: ${bgColor}`);
    
                if (bgColor === "rgb(255, 0, 0)") {  // Red color
                    isRed = true;
                } else if (bgColor === "rgb(255, 255, 0)") {  // Yellow color
                    isYellow = true;
                }
            } else {
                console.warn(`Row ${i} not found.`);
            }
        }
    
        // Set overall status based on color conditions
        if (isRed) {
            overallStatus.value = "REJECT";
            overallStatus.style.backgroundColor = "red";
        } else if (isYellow) {
            overallStatus.value = "REWORK";
            overallStatus.style.backgroundColor = "yellow";
        } else {
            overallStatus.value = "ACCEPT";
            overallStatus.style.backgroundColor = "#00ff00";
        }
    }
    
    // Disable button after completion
    function finalizeUI() {
        button.disabled = true;
        button.style.opacity = "0.5";
        button.style.pointerEvents = "auto";
    }
    
    
    
    // Collect data from the final step
    function collectFinalData() {
        console.log("ðŸš€ Final Step Reached: Collecting Data");
    
        let paramValues = [], curValues = [], maxValues = [], minValues = [], tirValues = [];
        let curBackgroundColors = [], statusValues = [];
    
        // Define the color-to-status mapping
        const statusMap = {
            "rgb(0, 255, 0)": "ACCEPT",  // Green
            "rgb(255, 255, 0)": "REWORK", // Yellow
            "rgb(255, 0, 0)": "REJECT"    // Red
        };
    
        for (let i = 1; i <= 21; i++) {
            ['param', 'cur', 'max', 'min', 'tir'].forEach(field => {
                let input = document.getElementById(`${field}_${i}`);
                if (input && input.value.trim()) {
                    eval(`${field}Values`).push(input.value.trim());
    
                    // Log collected value
                    console.log(`${field.toUpperCase()}_${i}:`, input.value.trim());
    
                    // If the field is "cur", collect and map background color to status
                    if (field === 'cur') {
                        let bgColor = window.getComputedStyle(input).backgroundColor;
                        let status = statusMap[bgColor] || "UNKNOWN"; // Default to UNKNOWN if no match
    
                        curBackgroundColors.push(bgColor);
                        statusValues.push(status);
    
                        console.log(`CUR_${i} Background Color:`, bgColor);
                        console.log(`CUR_${i} Status:`, status);
                    }
                } else {
                    console.log(`${field.toUpperCase()}_${i}: (No Data or Element Missing)`);
                }
            });
        }
    
        console.log("ðŸ“Š Collected Data:");
        console.log("paramValues:", paramValues);
        console.log("curValues:", curValues);
        console.log("curBackgroundColors:", curBackgroundColors);
        console.log("statusValues:", statusValues);
        console.log("maxValues:", maxValues);
        console.log("minValues:", minValues);
        console.log("tirValues:", tirValues);
    
        DataToSend(paramValues, curValues, maxValues, minValues, tirValues,statusValues);
    }
    
    
    let allowFunctionKeys = false; // Initially block F4 and F5
    
    function handleKeyPress(event) {
        const punchOverlay = document.getElementById('punch_no_container');
    
        // Block F4/F5 if function keys not allowed OR punch overlay is visible
        if (
            !allowFunctionKeys || 
            (punchOverlay && punchOverlay.style.display === 'flex')
        ) {
            return;
        }
    
        if ((event.key === 'F4' && isStart) || (event.key === 'F5' && !isStart)) {
            event.preventDefault();
            handleAction();
        }
    }
    
    // Attach the listener
    document.addEventListener('keydown', handleKeyPress);
    
    
    
    // Update button text and ID
    function updateButton(text, id) {
        button.innerHTML = text;
        button.id = id;
    }
    
    // Initialize when DOM is ready
    document.addEventListener('DOMContentLoaded', initElements);
    
    
    
    
    
    
    
    
    
    // function handleActionStart(timer) { 
        
    //     const button = document.querySelector('[id="rest-btn"],[id="start-btn"]');
    //     console.log("button",button)
    //     const notificationBar = document.getElementById('notification_bar');
    
        
    //     if (!button) {
    //         console.error("Button not found!");
    //         return;
    //     }
    
    //     let updateInterval = null;
    //     let stepNow = currentStep; // Store the current step at function start
    
    //     console.log(`Start action triggered for Step ${stepNow}!`);
    //     notificationBar.value = `MEASUREMENT IS STARTING FOR STEP ${stepNow} `;
    
    //     button.innerHTML = `STOP[F5] - Step ${stepNow}`;
    //     button.id = 'stop-btn';
    
    //     button.disabled = true; // Disable button
    //             button.style.filter = "blur(3px)"; // Apply blur effect
    //             button.style.pointerEvents = "none"; // Disable interactions
    
    //     let indices = responseData.stepNoArray
    //         .map((step, index) => parseInt(step) === stepNow ? index : -1)
    //         .filter(index => index !== -1);
    
    //         updateInterval = setInterval(() => {
    //     console.log("======= Starting new interval =======");
    //     console.log("ðŸ” Full gaugeOutputs:", JSON.stringify(gaugeOutputs, null, 2));
    
    //     Object.entries(gaugeOutputs).forEach(([groupKey, gaugeGroup]) => {
    //         console.log(`ðŸ“¦ Group Key: ${groupKey}, Gauge Group:`, gaugeGroup);
    
    //         Object.entries(gaugeGroup).forEach(([key1, value1]) => {
    //             console.log(`ðŸ”‘ Intermediate Key: ${key1}, Value:`, value1);
    
    //             // If value1 is a nested object (like {3: 12.47})
    //             if (typeof value1 === 'object' && value1 !== null) {
    //                 Object.entries(value1).forEach(([gaugeIndexStr, val]) => {
    //                     let gaugeIndex = parseInt(gaugeIndexStr);
    //                     console.log(`âœ… Calling updateMaxMinTir for gaugeIndex: ${gaugeIndex}`);
    //                     updateMaxMinTir(gaugeIndex);
    //                 });
    //             } else {
    //                 // Just in case it's not an object
    //                 let gaugeIndex = parseInt(key1);
    //                 console.log(`âœ… Calling updateMaxMinTir for gaugeIndex: ${gaugeIndex}`);
    //                 updateMaxMinTir(gaugeIndex);
    //             }
    //         });
    //     });
    // }, 100);
    
    
    //     // âœ… Stop after `timer` seconds and proceed to the next step
    //     setTimeout(() => {
    //         console.log(`Stop action triggered for Step ${stepNow}!`);
    //         notificationBar.value = `MEASUREMENT IS COMPLETED FOR STEP ${stepNow} `;
    
    //         button.innerHTML = `START[F4] - Step ${stepNow + 1}`;  // Now correctly displays next step
    //         button.id = 'start-btn';
    //         clearInterval(updateInterval);
    
    //         // Extract indices for the current step
    //         let container = indices.length;
    //         let parameterNames = indices.map(index => responseData.parameterNameArray[index]);
    
    //         updateTableValues(stepNow, indices, parameterNames, container);
    
    //         // âœ… Clear max, min, and tir fields
    //         indices.forEach((index, displayIndex) => {
    //             let gaugeIndex = displayIndex + 1;
    //             let maxField = document.getElementById(`max${gaugeIndex}`);
    //             let minField = document.getElementById(`min${gaugeIndex}`);
    //             let tirField = document.getElementById(`tir${gaugeIndex}`);
    
    //             if (maxField) maxField.value = "";
    //             if (minField) minField.value = "";
    //             if (tirField) tirField.value = "";
    //         });
    
    //         button.disabled = false; // Disable button
    //             button.style.filter = ""; // Apply blur effect
    //             button.style.pointerEvents = ""; // Disable interactions
    
             
    //         // âœ… Ensure `currentStep` only increments once per execution
    //         if (button.id === 'start-btn') {
    //             currentStep = stepNow + 1; // Ensure only a single increment
    //             updateUI(responseData);
    //             if (currentStep > totalSteps) {
           
    //         console.log("All steps completed!");
    //         notificationBar.value = "YOU HAVE COMPLETED THE MEASUREMENT FOR THIS JOB. DO THE NEXT JOB.";
    //         updateButton("START[F4]", "start-btn");
    //         finalizeUI();
    //         checkOverallStatus();
    //         collectFinalData();
    //     }
    //         }
    
    //     }, timer * 1000);
    // }
    
    
    
    
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
    let gaugeOutputs = {};
    let probeIntervals = {};
    let activeStep = null;
    let stepAutomationMap = {};
    let autoStartedSteps = new Set();
    let autoStartTimeouts = {};
    let autoStopTimeouts = {};
    
    function displaySerialData(
        parameterName, probeNumber, lowMaster, highMaster, lsl, usl, ltl, utl,
        stepNo, autoMan, timer, digits, e_value, d_value, o1_value,
        gaugeIndex, a1_value, parameter_factor_values, single_double, b_value, b1_value
    ) {
        console.log("StepNo:", stepNo);
        console.log("parameterName:", parameterName);
        console.log("autoMan:", autoMan);
        console.log("timer:", timer);
        console.log("a1_value:", a1_value);
        console.log("gaugeIndex JJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJ:", gaugeIndex);
        console.log("probeNumber:", probeNumber);
        console.log("single_double :", single_double);
        console.log("b_value:", b_value);
        console.log("b1_value:", b1_value);
        console.log("parameter_factor_values ", parameter_factor_values);
    
    
        console.log("e_value:", e_value);
        console.log("d_value:", d_value);
        console.log("o1_value:", o1_value);
    
        stepAutomationMap[stepNo] = autoMan;
        console.log(`Step ${stepNo} is ${autoMan ? 'AUTO' : 'MANUAL'}`);
    
        allowFunctionKeys = !autoMan;
        console.log(`${allowFunctionKeys ? 'âœ…' : 'âŒ'} F4/F5 ${allowFunctionKeys ? 'ENABLED' : 'DISABLED'} for Step ${stepNo}`);
    
        let notificationBar = document.getElementById('notification_bar');
        const button = document.querySelector('[id="rest-btn"],[id="start-btn"]');
    
       // Enable/Disable button based on mode (AUTO vs MANUAL)
    if (button) {
        if (autoMan === true) {
            button.disabled = true;
            button.style.filter = "blur(3px)";
            button.style.pointerEvents = "none";
            console.log("ðŸ”’ AUTO MODE: Button disabled for Step", stepNo);
        } else {
            button.disabled = false;
            button.style.filter = "none";
            button.style.pointerEvents = "auto";
            console.log("ðŸ”“ MANUAL MODE: Button enabled for Step", stepNo);
        }
    }
    
       
    
        const textareaId = mapProbeToTextareaId(probeNumber);
        const textarea = document.getElementById(textareaId);
    
        if (!textarea) {
            console.warn(`Textarea with ID ${textareaId} not found.`);
            return;
        }
    
        if (activeStep !== stepNo) {
            console.log(`Step changed from ${activeStep} to ${stepNo}. Clearing previous intervals.`);
            clearAllIntervals();
            activeStep = stepNo;
        }
    
        const intervalKey = `${stepNo}_${probeNumber}_${gaugeIndex}`;
        console.log("intervalKey:", intervalKey);
    
        if (probeIntervals[intervalKey]) {
            clearInterval(probeIntervals[intervalKey]);
            delete probeIntervals[intervalKey];
        }
    
        let lastValue = null;
    
        function updateCalculation() {
            const newSerialData = !isNaN(parseFloat(textarea.value)) ? parseFloat(textarea.value) : 0;
    
            if (newSerialData === lastValue) return;
            lastValue = newSerialData;
    
            const numericEValue = parseFloat(e_value) || 0;
            const numericDValue = parseFloat(d_value) || 0;
            const numericO1Value = parseFloat(o1_value) || 0;
            const numericBValue = parseFloat(b_value) || 0;
            const numericB1Value = parseFloat(b1_value) || 0;
    
            let displayOutput;
    
            if (single_double === true) {
                const displayOutput1 = (newSerialData - numericB1Value) * numericDValue;
                displayOutput = displayOutput1 + numericEValue + numericBValue;
                console.log(`ðŸ”¹ Using SINGLE mastering formula for gauge ${gaugeIndex}`);
            } else {
                displayOutput = numericEValue + (newSerialData * numericDValue + numericO1Value);
                console.log(`ðŸ”¸ Using DOUBLE mastering formula for gauge ${gaugeIndex}`);
            }
    
            displayOutput = parseFloat(displayOutput.toFixed(digits));
            console.log("displayOutput kkkkkkkkkkkkkkkkyyyyyyyyyyyyyyuuuuuuuuuuu ",displayOutput)
    
            for (let i = 0; i < parameter_factor_values.length; i++) {
                const factor = parameter_factor_values[i];
                const factorName = factor.parameter_name;
                const method = factor.method;
                const factorValue = parseFloat(factor.value);
    
                if (factorName === parameterName) {
                    displayOutput = method === '+' ? displayOutput + factorValue : displayOutput - factorValue;
                    displayOutput = parseFloat(displayOutput.toFixed(digits));
                }
            }
    
            if (!isNaN(displayOutput)) {
                gaugeOutputs[stepNo] = gaugeOutputs[stepNo] || {};
                gaugeOutputs[stepNo][probeNumber] = gaugeOutputs[stepNo][probeNumber] || {};
                gaugeOutputs[stepNo][probeNumber][gaugeIndex] = displayOutput;
            }
    
            console.log(`displayOutput for Gauge ${gaugeIndex} (Step ${stepNo}, Probe ${probeNumber}):`, displayOutput);
    
            const outputBoxId = `Output_box${gaugeIndex}`;
            const outputBox = document.getElementById(outputBoxId);
    
            if (outputBox) {
                outputBox.value = displayOutput.toFixed(digits);
    
                if (displayOutput < ltl) {
                    outputBox.style.backgroundColor = "red";
                } else if (displayOutput >= ltl && displayOutput < lsl) {
                    outputBox.style.backgroundColor = "yellow";
                } else if (displayOutput >= lsl && displayOutput <= usl) {
                    outputBox.style.backgroundColor = "#00ff00";
                } else if (displayOutput > usl && displayOutput <= utl) {
                    outputBox.style.backgroundColor = "yellow";
                } else if (displayOutput > utl) {
                    outputBox.style.backgroundColor = "red";
                }
            } else {
                console.warn(`Output box ${outputBoxId} not found`);
            }
    
            const ltl_value = (parseFloat(ltl) - 0.030).toFixed(4);
            const utl_value = (parseFloat(utl) + 0.030).toFixed(4);
            const inRange = displayOutput >= ltl_value && displayOutput <= utl_value;
            const autoKey = `${stepNo}_${probeNumber}_${gaugeIndex}`;
    
            if (autoMan && timer) {
        if (!window.validOutputMap) {
            console.log("ðŸ”§ Creating global validOutputMap...");
            window.validOutputMap = {};
        }
    
        if (!validOutputMap[stepNo]) {
            console.log(`ðŸ“¦ Creating Set for Step ${stepNo} in validOutputMap`);
            validOutputMap[stepNo] = new Set();
        }
    
        const isWithinRange = displayOutput >= parseFloat(ltl_value) && displayOutput <= parseFloat(utl_value);
        console.log(`ðŸ“ Range Check for '${parameterName}' = ${displayOutput} (Allowed: ${ltl_value} - ${utl_value}) âžœ ${isWithinRange ? 'âœ… IN RANGE' : 'âŒ OUT OF RANGE'}`);
    
        if (isWithinRange) {
            validOutputMap[stepNo].add(parameterName);
            console.log(`âœ… ${parameterName} is valid for Step ${stepNo} (${displayOutput})`);
    
            const fixed_channel_array = responseData.fixed_channel_array;
    
        const matchedIndices = [];
        const matchedGauges = [];
    
        responseData.stepNoArray.forEach((step, index) => {
            if (parseInt(step) === currentStep) {
                matchedIndices.push(index);
                matchedGauges.push(fixed_channel_array[index]);
            }
        });
    
            // Count all unique parameters in this step
            const totalParams = matchedIndices.length;
            console.log("gaugeOutputs[stepNo]",gaugeOutputs[stepNo])
            console.log(`ðŸ”¢ Valid: ${validOutputMap[stepNo].size}/${totalParams}`);
    
            if (validOutputMap[stepNo].size >= totalParams) {
                // âœ… All parameters are valid â€“ trigger auto start + stop
                console.log(`ðŸŸ¢ All parameters valid for Step ${stepNo}. Triggering measurement...`);
    
                const autoKey = `AUTO_FULL_${stepNo}`;
                if (!autoStartTimeouts[autoKey]) {
                    autoStartTimeouts[autoKey] = setTimeout(() => {
                        if (!autoStartedSteps.has(stepNo)) {
                            autoStartedSteps.add(stepNo);
                            startAction();
    
                            autoStopTimeouts[autoKey] = setTimeout(() => {
                                stopAction();
                                delete autoStopTimeouts[autoKey];
                            }, timer * 1000);
    
                            console.log(`â±ï¸ stopAction will trigger in ${timer} sec`);
                        }
    
                        delete autoStartTimeouts[autoKey];
                        validOutputMap[stepNo].clear();
                    }, 500);
                }
            }
    
        } else {
            validOutputMap[stepNo].delete(parameterName);
            console.warn(`âŒ ${parameterName} OUT OF RANGE (${displayOutput})`);
        }
    }
     else {
                // âŒ Cancel timers if out of range
                if (autoStartTimeouts[autoKey]) {
                    console.log(`ðŸ›‘ AUTO: Cancelling start timer for ${autoKey}`);
                    clearTimeout(autoStartTimeouts[autoKey]);
                    delete autoStartTimeouts[autoKey];
                }
                if (autoStopTimeouts[autoKey]) {
                    console.log(`ðŸ›‘ AUTO: Cancelling stop timer for ${autoKey}`);
                    clearTimeout(autoStopTimeouts[autoKey]);
                    delete autoStopTimeouts[autoKey];
                }
            }
        }
    
        probeIntervals[intervalKey] = setInterval(updateCalculation, 100);
    }
    
    function clearAllIntervals() {
        for (let key in probeIntervals) {
            clearInterval(probeIntervals[key]);
            delete probeIntervals[key];
        }
        console.log("All previous intervals cleared.");
    }
    
    
    
    
    
    
    
    
    
    function updateMaxMinTir(gaugeIndex) {
        let outputBox = document.getElementById(`Output_box${gaugeIndex}`);
        console.log("outputBox",outputBox)
        console.log("gaugeIndex",gaugeIndex)
    
        if (!outputBox || isNaN(parseFloat(outputBox.value))) {
            console.warn(`No valid data for Gauge ${gaugeIndex}`);
            return;
        }
    
        let currentValue = parseFloat(outputBox.value);
    
        // Get corresponding max, min, and tir fields
        let maxField = document.getElementById(`max${gaugeIndex}`);
        let minField = document.getElementById(`min${gaugeIndex}`);
        let tirField = document.getElementById(`tir${gaugeIndex}`);
    
        // Ensure previous values exist
        let previousMax = parseFloat(maxField.value) || currentValue;
        let previousMin = parseFloat(minField.value) || currentValue;
    
        // Update max and min dynamically
        let newMax = Math.max(previousMax, currentValue);
        let newMin = Math.min(previousMin, currentValue);
        let newTir = ((newMax - newMin) / 2).toFixed(4);
    
        // Update the fields
        maxField.value = newMax.toFixed(4);
        minField.value = newMin.toFixed(4);
        tirField.value = newTir;
    }
    
    
    
    
    
    
    
    // let maxVisibleRow = 0; // Track the highest row number that should be shown
    
    // function updateTableValues(step, indices, parameterNames, container) {
    //     console.log("Step:", step, "Indices:", indices, "Parameter Names:", parameterNames);
    
         
    
    //     if (!Array.isArray(parameterNames) || parameterNames.length === 0) {
    //         console.error("parameterNames array is empty or not an array:", parameterNames);
    //         return;
    //     }
    
    //     // Update maxVisibleRow based on the new indices
    //     let newMax = Math.max(...indices.map(i => i + 1));
    //     if (newMax > maxVisibleRow) {
    //         maxVisibleRow = newMax;
    //     }
    
    //     // Show all rows from 1 to maxVisibleRow
    //     for (let i = 1; i <= 21; i++) {
    //         let row = document.getElementById(`row_${i}`);
    //         if (row) row.style.display = (i <= maxVisibleRow) ? "" : "none";
    //     }
    
    //     // Update only the rows we are passed
    //     indices.forEach((index, paramIndex) => {
    //         let rowIndex_table = index + 1;
    
    //         let paramInput = document.getElementById(`param_${rowIndex_table}`);
    //         let curInput = document.getElementById(`cur_${rowIndex_table}`);
    //         let maxInput = document.getElementById(`max_${rowIndex_table}`);
    //         let minInput = document.getElementById(`min_${rowIndex_table}`);
    //         let tirInput = document.getElementById(`tir_${rowIndex_table}`);
    
    //         if (!paramInput) {
    //             console.warn(`paramInput for Row ${rowIndex_table} not found.`);
    //             return;
    //         }
    
    //         let paramName = parameterNames[paramIndex] !== undefined ? parameterNames[paramIndex] : "UNKNOWN";
    //         paramInput.value = paramName;
    
    //         let targetIndex = indices.length === 1 ? container : paramIndex + 1;
    
    //         let outputBox = document.getElementById(`Output_box${targetIndex}`);
    //         let maxBox = document.getElementById(`max${targetIndex}`);
    //         let minBox = document.getElementById(`min${targetIndex}`);
    //         let tirBox = document.getElementById(`tir${targetIndex}`);
    
    //         if (curInput && maxInput && minInput && tirInput && outputBox && maxBox && minBox && tirBox) {
    //             curInput.value = outputBox.value;
    //             maxInput.value = maxBox.value;
    //             minInput.value = minBox.value;
    //             tirInput.value = tirBox.value;
    
    //             outputBox.addEventListener("input", function () {
    //                 let existingBgColor = curInput.style.backgroundColor;
    //                 let computedBgColor = window.getComputedStyle(outputBox).backgroundColor;
    
    //                 if (!existingBgColor || existingBgColor === "rgba(0, 0, 0, 0)" || existingBgColor === "transparent") {
    //                     curInput.style.backgroundColor = computedBgColor;
    //                 }
    //             });
    
    //             outputBox.dispatchEvent(new Event("input"));
    //         } else {
    //             console.warn(`Some elements missing for Row ${targetIndex}`);
    //         }
    //     });
    
    //     const containerDiv = document.getElementById("output_values_container");
    // const lastRow = document.getElementById(`row_${maxVisibleRow}`);
    // if (containerDiv && lastRow) {
    //     lastRow.scrollIntoView({ behavior: "smooth", block: "end" });
    // }
    
    
    // }
    
    
    let globalRowCounter = 0;
    
    
    function updateTableValues(step, indices, parameterNames, container, matchedGauges) {
        console.log("Step:", step, "Indices:", indices, "Parameter Names:", parameterNames);
        console.log("Matched Gauges:", matchedGauges);
    
        if (!Array.isArray(parameterNames) || parameterNames.length === 0) {
            console.error("parameterNames array is empty or not an array:", parameterNames);
            return;
        }
    
        indices.forEach((index, rowNumber) => {
            globalRowCounter += 1; // Move to next available row
            const displayRow = globalRowCounter;
            const gaugeIndex = matchedGauges[rowNumber]; // like '1', '3', etc.
    
            // Target display fields
            const paramInput = document.getElementById(`param_${displayRow}`);
            const curInput = document.getElementById(`cur_${displayRow}`);
            const maxInput = document.getElementById(`max_${displayRow}`);
            const minInput = document.getElementById(`min_${displayRow}`);
            const tirInput = document.getElementById(`tir_${displayRow}`);
    
            // Source gauge fields
            const outputBox = document.getElementById(`Output_box${gaugeIndex}`);
            const maxBox = document.getElementById(`max${gaugeIndex}`);
            const minBox = document.getElementById(`min${gaugeIndex}`);
            const tirBox = document.getElementById(`tir${gaugeIndex}`);
    
            if (paramInput && outputBox && maxBox && minBox && tirBox && curInput && maxInput && minInput && tirInput) {
                paramInput.value = parameterNames[rowNumber] || "UNKNOWN";
                curInput.value = outputBox.value;
                maxInput.value = maxBox.value;
                minInput.value = minBox.value;
                tirInput.value = tirBox.value;
    
                // Background color
                const bgColor = window.getComputedStyle(outputBox).backgroundColor;
                curInput.style.backgroundColor = bgColor;
            } else {
                console.warn(`âš ï¸ Missing elements for displayRow ${displayRow} (gauge ${gaugeIndex})`);
            }
        });
    
    
    
    
        // Scroll to bottom visible row if needed
        const containerDiv = document.getElementById("output_values_container");
        const lastRow = document.getElementById(`row_${Math.max(...indices.map(i => i + 1))}`);
        if (containerDiv && lastRow) {
            lastRow.scrollIntoView({ behavior: "smooth", block: "end" });
        }
    }
    
    
    
    
    function DataToSend(paramValues, curValues, maxValues, minValues, tirValues, statusValues) {
       

         // ðŸ” Reset clear_table = false at the beginning
        fetch("/reset-clear-flag/")
            .then(res => res.json())
            .then(data => {
                
                console.log("clear_table reset to FALSE:", data);
            });

        $('#loading_spinner').show();
    
        const overallStatusInput = document.getElementById("overall_status").value;
        const partModel = document.getElementById("part_model").value;
        const partName = document.getElementById("part_no").value;
        const date = document.getElementById("date_time").value;
        const operator = document.getElementById("operator").value;
        const shift = document.getElementById("shift").value;
        const punchNo = document.getElementById("punch_no").value;
    
         // âœ… Validate top-level mandatory fields first
         if (!partModel || !partName || !date || !operator || !shift ) {
            $('#loading_spinner').hide();
            showNotifications("Please fill all required header fields before submitting.");
            return;
        }
    
        const parameterName = responseData.parameterNameArray;  
        const lsl = responseData.lslArray;
        const usl = responseData.uslArray;
        const ltl = responseData.ltlArray;
        const utl = responseData.utlArray;
        const nominal = responseData.nominalArray;
    
        let dataToSend = [];
    
        // First, check that all mandatory fields are present
        for (let i = 0; i < paramValues.length; i++) {
            if (
                !paramValues[i] || 
                !curValues[i] || 
                !maxValues[i] || 
                !minValues[i] || 
                !tirValues[i] || 
                !statusValues[i] ||
                !overallStatusInput
            ) {
                $('#loading_spinner').hide();
                showNotifications(`Row ${i + 1} or Overall Status is incomplete. Please fill all fields before submitting.`);
                setTimeout(() => {
                    location.reload();
                }, 1000);
                return; // Stop if any field is missing
               
            }
    
            dataToSend.push({
                date: date,
                punchNo: punchNo,
                partModel: partModel,
                partName: partName,
                operator: operator,
                shift: shift,
                parameterName: paramValues[i],
                lsl: lsl[i] || "",
                usl: usl[i] || "",
                ltl: ltl[i] || "",
                utl: utl[i] || "",
                nominal: nominal[i] || "",
                output: curValues[i],
                max: maxValues[i],
                min: minValues[i],
                tir: tirValues[i],
                statusCell: statusValues[i],
                overallStatusInput: overallStatusInput,
            });
        }
    
        console.log("Data being sent to the backend:", dataToSend);
    
        // All rows valid, proceed to send
        $.ajax({
            url: '/measure_data/',
            type: 'POST',
            headers: { 'X-CSRFToken': getCSRFToken() },
            data: JSON.stringify(dataToSend),
            contentType: 'application/json',
            success: function (response) {
                $('#loading_spinner').hide();
                console.log('Data successfully sent to the backend:', response);
                showNotification('DATA SAVED', true);
                setTimeout(() => {
                    location.reload();
                }, 1000);
            },
            error: function (error) {
                console.error('Error sending data to the backend:', error);
                showNotification('Error sending data to the backend.', false);
                $('#loading_spinner').hide();
            }
        });
    }
    
    
    function showNotification(message, isSuccess) {
        const notifyDiv = document.querySelector('.notify');
        notifyDiv.innerHTML = message;
    
        notifyDiv.style.display = 'block';
        notifyDiv.style.position = 'fixed';
        notifyDiv.style.top = '10vh';                    // 5% from top
        notifyDiv.style.left = '50vw';                  // Center horizontally
        notifyDiv.style.transform = 'translateX(-50%)'; // Center align
    
        notifyDiv.style.backgroundColor = isSuccess ? 'green' : 'red';
        notifyDiv.style.color = 'white';
        notifyDiv.style.padding = '2vh 4vw';            // Vertical and horizontal padding
        notifyDiv.style.borderRadius = '2vh';
        notifyDiv.style.fontSize = '2.5vw';             // Font size relative to viewport height
        notifyDiv.style.textAlign = 'center';
        notifyDiv.style.zIndex = '9999';
        notifyDiv.style.fontWeight = 'bold';
    
    
                     // Minimum width of box
        notifyDiv.style.width = '80vw';  
        notifyDiv.style.height = '10vw';             // Responsive max width
       
         
    
        notifyDiv.style.boxShadow = '0 1vh 3vh rgba(0, 0, 0, 0.3)';
    
        // Hide after 5 seconds
        setTimeout(() => {
            notifyDiv.style.display = 'none';
        }, 5000);
    }
    
    
      
    // Helper function to get CSRF token from the browser's cookies
    function getCSRFToken() {
        const csrfToken = document.cookie
            .split('; ')
            .find(row => row.startsWith('csrftoken'))
            ?.split('=')[1];
        return csrfToken;
    }
    
    
    
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
    // Function to map probe numbers to textarea IDs
    function mapProbeToTextareaId(probeNumber) {
        const probeMapping = {
            1: "probe-A",
            2: "probe-B",
            3: "probe-C",
            4: "probe-D",
    
            5: "probe-E",
            6: "probe-F",
            7: "probe-G",
            8: "probe-H",
    
            9: "probe-I",
            10: "probe-J",
            11: "probe-K",
        };
    
        return probeMapping[probeNumber] || null; // Return null if no mapping is found
    }
    
    
    ////////////////////////////////////////////////////////////////////////////
    
    $(document).ready(function () {
        // Function to trigger the same functionality as button click
        function triggerAjaxRequest() {
            const partName = $("#part_model").val(); // Capture the input value
            $.ajax({
                url: "{% url 'master' %}", // URL for 'newma' view
                method: "POST",
                headers: { "X-CSRFToken": "{{ csrf_token }}" },
                data: { part_model: partName }, // Send the part_model
                success: function (response) {
                    if (response.redirect_url) {
                        // Redirect to newma and send part_model as a query parameter
                        window.location.href = response.redirect_url + "?part_model=" + encodeURIComponent(partName);
                    }
                },
                error: function (xhr, status, error) {
                    console.error("Error:", error);
                },
            });
        }
    
        // Trigger the function when the button is clicked
        $("#master_btn").click(function () {
            triggerAjaxRequest();
        });
    
        // // Trigger the function when the F1 key is pressed
        // $(document).keydown(function (e) {
        //     if (e.key === "F1") { // Check if the pressed key is F1
        //         e.preventDefault(); // Prevent the default F1 action (help page)
        //         triggerAjaxRequest(); // Trigger the AJAX request
        //     }
        // });
    });
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
    
    
    
    function sendPartModelForCount(partModel) {
        $.ajax({
            url: "/changed_name/", // URL for 'measurement' view
            method: "POST",
            headers: { "X-CSRFToken": "{{ csrf_token }}" },
            data: JSON.stringify({ part_names: partModel }), // Send partModel as JSON
            contentType: "application/json", // Specify JSON content type
            success: function (response) {
                console.log("Part model sent successfully yyyyyyyyyyyyyyyyyy:", partModel);
                console.log("Response from server: jjjjjjjjjjjjjjjjjjjjjjjjj", response);
    
            },
            error: function (error) {
                console.error("Error sending part model:", error);
            },
        });
    }
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
    
    document.addEventListener("DOMContentLoaded", function () {
        // Event listener for report_btn_main click
        document.getElementById("report_btn_main").addEventListener("click", function () {
            // Show the two additional buttons when the main button is clicked
            document.getElementById("spc_btn").style.display = "inline-block";
            document.getElementById("report_btn").style.display = "inline-block"; // Show the report button as well
        });
    
        // Event listener for the report_btn click (this will trigger the redirect)
        document.getElementById("report_btn").addEventListener("click", function () {
            const partName = document.getElementById("part_model").value.trim();
    
            if (!partName) {
                showNotifications("Please enter a part model!");
                return;
            }
    
            // Redirect to the report/ page with the part_model as a query parameter
            const redirectUrl = `/report/?part_model=${encodeURIComponent(partName)}`;
            window.location.href = redirectUrl;
        });
        
        // Optional: F6 key press listener to trigger the same action as the report_btn click
        document.addEventListener("keydown", function (e) {
            if (e.key === "F6") { // Check if F6 key is pressed
                e.preventDefault(); // Prevent default behavior of F6
                document.getElementById("report_btn_main").click(); // Simulate a click on the report_btn
            }
        });
    
         // Optional: F6 key press listener to trigger the same action as the report_btn click
         document.addEventListener("keydown", function (e) {
            if (e.key === "F8") { // Check if F6 key is pressed
                e.preventDefault(); // Prevent default behavior of F6
                document.getElementById("report_btn").click(); // Simulate a click on the report_btn
            }
        });
    });
    
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
        document.addEventListener("DOMContentLoaded", function () {
        // Function to handle the click event
        function handleClickspc() {
            const partName = document.getElementById("part_model").value.trim();
    
            if (!partName) {
                showNotifications("Please enter a part model!");
                return;
            }
    
            // Redirect to the report/ page with the part_model as a query parameter
            const redirectUrl = `/spc/?part_model=${encodeURIComponent(partName)}`;
            window.location.href = redirectUrl;
        }
    
        // Event listener for the button click
        document.getElementById("live_spc_btn").addEventListener("click", handleClickspc);
    
        // // Event listener for the F3 key press
        // document.addEventListener("keydown", function (e) {
        //     if (e.key === "F3") { // Check if the pressed key is F3
        //         e.preventDefault(); // Prevent the default F3 action
        //         handleClickspc(); // Trigger the handleClick function
        //     }
        // });
    });
    
    
    ///////////////////////////////////////////////////////////////////////////////////////////
    
    document.addEventListener("DOMContentLoaded", function () {
        // Function to handle the click event
        function handleClickspcCharts() {
            const partName = document.getElementById("part_model").value.trim();
    
            if (!partName) {
                showNotifications("Please enter a part model!");
                return;
            }
    
            // Redirect to the report/ page with the part_model as a query parameter
            const redirectUrl = `/spcCharts/?part_model=${encodeURIComponent(partName)}`;
            window.location.href = redirectUrl;
        }
    
        // Event listener for the button click
        document.getElementById("spc_btn").addEventListener("click", handleClickspcCharts);
    
        // Event listener for the F3 key press
        document.addEventListener("keydown", function (e) {
            if (e.key === "F7") { // Check if the pressed key is F3
                e.preventDefault(); // Prevent the default F3 action
                handleClickspcCharts(); // Trigger the handleClick function
            }
        });
    });
    
    
    
    
    
    
    var shiftValues = JSON.parse('{{ shift_time|escapejs }}');
    console.log('Shift values:', shiftValues);
    
    var operator = JSON.parse('{{ user_name|escapejs }}');
    console.log('operator name is this values:', operator);
    
    if (Array.isArray(operator) && operator.length > 0) {
            document.getElementById('operator').value = operator[0].username;
        } else {
            console.error('No operator data found');
        }
    
        
    // Function to convert 12-hour time to 24-hour format
    function convertTo24Hour(timeString) {
        let [time, modifier] = timeString.trim().split(' ');
        let [hours, minutes, seconds] = time.split(':');
        if (modifier === 'PM' && hours !== '12') {
            hours = parseInt(hours, 10) + 12;
        }
        if (modifier === 'AM' && hours === '12') {
            hours = 0;
        }
        return `${hours.toString().padStart(2, '0')}:${minutes}:${seconds}`;
    }
    
    // Function to determine and update the shift name based on the current time
    function setDateTimes() {
        let now = new Date();
        let currentTime = now.toTimeString().split(' ')[0]; // 'HH:MM:SS'
        let currentDate = now.toISOString().split('T')[0]; // 'YYYY-MM-DD'
    
        // Determine the shift based on the current time
        let shiftName = null;
        for (let i = shiftValues.length - 1; i >= 0; i--) {
            let shift = shiftValues[i];
            let shiftTime = shift.shift_time.trim();  // Trim whitespace from shift_time
            let shift24HourTime = convertTo24Hour(shiftTime);
    
            if (currentTime >= shift24HourTime) {
                shiftName = shift.shift;  // Set the shift name (e.g., "SHIFT-1")
                break;
            }
        }
    
        // If no shift is found (e.g., if the current time is before all shifts), default to the first shift
        if (!shiftName) {
            shiftName = shiftValues[0].shift; // Default to the first shift
        }
    
        // Set the shift name in the input box
        let fromDateElements = document.getElementsByClassName('shift-name');
        for (let element of fromDateElements) {
            element.value = shiftName;  // Set the shift name in the input box
        }
    
    
    }
    
    // Function to update the current date and time in the input box and check for shift change
    function updateClock() {
        // Get the current date and time
        var currentDate = new Date();
        var hours = currentDate.getHours();
        var minutes = currentDate.getMinutes();
        var seconds = currentDate.getSeconds();
        var ampm = hours >= 12 ? 'PM' : 'AM';
    
        // Format the hours, minutes, and seconds
        hours = hours % 12;
        hours = hours ? hours : 12; // Handle midnight (0 hours)
        minutes = minutes < 10 ? '0' + minutes : minutes;
        seconds = seconds < 10 ? '0' + seconds : seconds;
    
        // Create the time string
        var currentTime = hours + ':' + minutes + ':' + seconds + ' ' + ampm;
    
        // Get the date components
        var day = currentDate.getDate();
        var month = currentDate.getMonth() + 1; // Month is zero-based
        var year = currentDate.getFullYear();
    
        // Create the date string
        var currentDateFormatted = day + '/' + month + '/' + year;
    
        // Set the value of the input box
        document.getElementById("date_time").value = currentDateFormatted + ' ' + currentTime;
    
        // Check if current time matches the next shift time
        checkShiftNotification(currentTime);
    
      
    
        // Call this function again after 1 second
        setTimeout(updateClock, 1000);
    }
    
    
    // Function to check if the current time matches the next shift time
    function checkShiftNotification(currentTime) {
        let shiftTime = null;
        for (let i = 0; i < shiftValues.length; i++) {
            let shift = shiftValues[i];
            let shiftTime24Hour = convertTo24Hour(shift.shift_time);
            if (currentTime >= shiftTime24Hour) {
                shiftTime = shift.shift_time;
                break;
            }
        }
    
        // If shift time is found and matches the current time, show notification
        if (shiftTime && currentTime === shiftTime) {
            showShiftNotification();
        }
    }
    
    // Function to get the shift time for a given shift name
    function getShiftTimeForShift(shiftName) {
        let shift = shiftValues.find(s => s.shift === shiftName);
        return shift ? shift.shift_time : null;
    }
    
    // Function to format shift time with the current date
    function combineShiftTimeWithCurrentDate(shiftName) {
        let shiftTime = getShiftTimeForShift(shiftName);
        if (!shiftTime) {
            console.error('Shift time not found for shift:', shiftName);
            return null;
        }
    
        let shift24HourTime = convertTo24Hour(shiftTime);
        let shiftDateTime = new Date();
        let [hours, minutes, seconds] = shift24HourTime.split(':');
        
        shiftDateTime.setHours(parseInt(hours));
        shiftDateTime.setMinutes(parseInt(minutes));
        shiftDateTime.setSeconds(parseInt(seconds));
    
        let day = shiftDateTime.getDate().toString().padStart(2, '0');
        let month = (shiftDateTime.getMonth() + 1).toString().padStart(2, '0');
        let year = shiftDateTime.getFullYear();
    
        let displayHours = shiftDateTime.getHours() % 12 || 12;
        let ampm = shiftDateTime.getHours() >= 12 ? 'PM' : 'AM';
        
        let formattedDateTime = `${year}-${month}-${day} ${displayHours}:${minutes}:${seconds} ${ampm}`;
        
        return formattedDateTime;
    }
    
    // Function to send shift data via AJAX
    // Function to send shift data via AJAX with from_date and end_date
    function postShiftData(shiftName) {
        let fromDate = combineShiftTimeWithCurrentDate(shiftName); // Shift start time (current date + shift time)
        console.log('your from data is this :',fromDate);
        let now = new Date();
    
        let day = now.getDate().toString().padStart(2, '0');
        let month = (now.getMonth() + 1).toString().padStart(2, '0');
        let year = now.getFullYear();
        let hours = now.getHours() % 12 || 12;
        let minutes = now.getMinutes().toString().padStart(2, '0');
        let seconds = now.getSeconds().toString().padStart(2, '0');
        let ampm = now.getHours() >= 12 ? 'PM' : 'AM';
    
        let endDate = `${year}-${month}-${day} ${hours}:${minutes}:${seconds} ${ampm}`;
    
    
    }
    
    
    
    
    
    
    function getCSRFToken(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            let cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                let cookie = cookies[i].trim();
                if (cookie.startsWith(name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
    
    
    
    
    function checkShiftChange() {
        let now = new Date();
        let currentTime = now.toTimeString().split(' ')[0];
        let currentShift = null;
        let previousShift = null;
    
        for (let i = 0; i < shiftValues.length; i++) {
            let shift = shiftValues[i];
            let shiftTime24Hour = convertTo24Hour(shift.shift_time);
    
            if (currentTime >= shiftTime24Hour) {
                previousShift = currentShift;
                currentShift = shift.shift;
            } else {
                break;
            }
        }
    
        // Check 5 seconds before next shift starts (existing logic)
        let nextShiftTime = null;
        for (let i = 0; i < shiftValues.length; i++) {
            let shiftTime24Hour = convertTo24Hour(shiftValues[i].shift_time);
            if (currentTime < shiftTime24Hour) {
                nextShiftTime = shiftTime24Hour;
                break;
            }
        }
    
        if (nextShiftTime) {
            let shiftDateTime = new Date();
            let [hours, minutes, seconds] = nextShiftTime.split(':');
            shiftDateTime.setHours(parseInt(hours));
            shiftDateTime.setMinutes(parseInt(minutes));
            shiftDateTime.setSeconds(parseInt(seconds) - 5);
    
            let shiftMinusFiveSec = shiftDateTime.toTimeString().split(' ')[0];
    
            if (currentTime === shiftMinusFiveSec && currentShift) {
                checkAndRedirect(currentShift);
            }
        }
    
        // NEW: Check if previous shift was missed and not redirected
        if (previousShift) {
            fetch(`/shift_redirect_status/?shift=${encodeURIComponent(previousShift)}`)
                .then(response => response.json())
                .then(data => {
                    if (!data.redirected) {
                        console.log('Missed previous shift redirect. Redirecting now...');
                        let fromDate = combineShiftTimeWithCurrentDate(previousShift);
                        let now = new Date();
                        let endDate = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')} ${now.getHours() % 12 || 12}:${String(now.getMinutes()).padStart(2, '0')}:${String(now.getSeconds()).padStart(2, '0')} ${now.getHours() >= 12 ? 'PM' : 'AM'}`;
                        var partModel = $("#part_model").val();
    
                        fetch('/save_shift_redirect/', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': getCSRFToken('csrftoken')
                            },
                            body: JSON.stringify({ shift: previousShift })
                        });
    
                        setTimeout(() => {
                            window.location.href = `/report/?from_date=${encodeURIComponent(fromDate)}&to_date=${encodeURIComponent(endDate)}&part_model=${encodeURIComponent(partModel)}`;
                        }, 1000);
                    }
                });
        }
    }
    
    function checkAndRedirect(shiftName) {
        fetch(`/shift_redirect_status/?shift=${encodeURIComponent(shiftName)}`)
            .then(response => response.json())
            .then(data => {
                if (!data.redirected) {
                    console.log('Redirecting to report page...');
    
                    let fromDate = combineShiftTimeWithCurrentDate(shiftName);
                    let now = new Date();
                    let endDate = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')} ${now.getHours() % 12 || 12}:${String(now.getMinutes()).padStart(2, '0')}:${String(now.getSeconds()).padStart(2, '0')} ${now.getHours() >= 12 ? 'PM' : 'AM'}`;
                    var partModel = $("#part_model").val();
    
                    fetch('/save_shift_redirect/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': getCSRFToken('csrftoken')
                        },
                        body: JSON.stringify({ shift: shiftName })
                    });
    
                    setTimeout(() => {
                        window.location.href = `/report/?from_date=${encodeURIComponent(fromDate)}&to_date=${encodeURIComponent(endDate)}&part_model=${encodeURIComponent(partModel)}`;
                    }, 1000);
                }
            });
    }
    
    
    
    // Function to display shift change notification
    function showShiftNotification() {
        let notification = document.createElement('div');
        notification.id = 'shift-notification';
        notification.innerText = 'It\'s time to switch to the next shift!';
        notification.style.position = 'fixed';
        notification.style.top = '10px';
        notification.style.right = '10px';
        notification.style.backgroundColor = 'green';
        notification.style.color = 'white';
        notification.style.padding = '10px';
        notification.style.borderRadius = '5px';
        document.body.appendChild(notification);
    
        // Remove the notification after 3 seconds and refresh the page
        setTimeout(function() {
            notification.style.display = 'none';
            location.reload(); // Refresh the page
        }, 3000);
    }
    
    // Call the function to initially display the clock
    updateClock();
    
    // Call setDateTimes every second to update the shift name
    setInterval(setDateTimes, 1000);
    
    setInterval(checkShiftChange, 500);
            
    
    
    
    // Initialize WebSocket connection
    // Initialize WebSocket connection
    const socket = new WebSocket('ws://localhost:8000/ws/measurement/');
    
    // Variables to track data activity
    let isConnected = false; // Tracks connection status
    let lastMessageTime = Date.now(); // Tracks the time of the last received message
    let timeoutDuration = 5000; // Set timeout duration (e.g., 5000ms = 5 seconds)
    
    // Function to check connection status periodically
    function checkConnection() {
        const currentTime = Date.now();
        const elapsedTime = currentTime - lastMessageTime;
    
        // Check if the elapsed time exceeds the timeout duration
        if (elapsedTime > timeoutDuration) {
            if (isConnected) {
                displayDisconnected(); // Change status to disconnected
                isConnected = false;  // Mark as disconnected
            }
        } else {
            if (!isConnected) {
                displayConnected(); // Change status to connected
                isConnected = true;  // Mark as connected
            }
        }
    }
    
    // Function to display "Connected" message
    function displayConnected() {
        const messageBox = document.getElementById("message");
        messageBox.value = "Connected";
        messageBox.style.color = "black";
        messageBox.style.backgroundColor = "green";
    }
    
    // Function to display "Disconnected" message
    function displayDisconnected() {
        const messageBox = document.getElementById("message");
        messageBox.value = "Disconnected";
        messageBox.style.color = "black";
        messageBox.style.backgroundColor = "red";
    }
    
    // Function to start serial communication
    function startSerialCommunication() {
        const messageBox = document.getElementById("message"); // Get the input box
        if (socket.readyState === WebSocket.OPEN) {
            const dbPort = document.getElementById("db_port").value;
            const comPorts = document.getElementById("com_ports").value;
            const baudRate = document.getElementById("baud_rate").value;
            const parity = document.getElementById("parity").value;
            const stopbit = document.getElementById("stopbit").value;
            const databit = document.getElementById("databit").value;
    
            console.log('COM port:', comPorts);
            console.log('DB port:', dbPort);
    
            if (dbPort === comPorts) {
                const comparableValue = dbPort; // If equal, use dbPort
                console.log("Matching Value:", comparableValue);
    
                socket.send(JSON.stringify({
                    command: 'start_serial',
                    com_port: dbPort,
                    baud_rate: baudRate,
                    parity: parity,
                    stopbit: stopbit,
                    databit: databit,
                }));
    
                displayConnected(); // Initially set to connected
                lastMessageTime = Date.now(); // Reset the timer
            } else {
                displayDisconnected(); // Set to disconnected if ports don't match
            }
        } else {
            setTimeout(startSerialCommunication, 100); // Retry every 100ms if WebSocket isn't ready
        }
    }
    
    // WebSocket event listeners
    socket.onopen = function(event) {
        console.log("WebSocket connection established.");
        startSerialCommunication();
    };
    
    // When data is received
    socket.onmessage = function(event) {
        const data = JSON.parse(event.data);
        const message = data.message;
    
        // Update last message time
        lastMessageTime = Date.now();
    
        // Append data to textarea
        const serialDataDisplay = document.getElementById("serial-data-display");
        serialDataDisplay.value += message + '\n';
        serialDataDisplay.scrollTop = serialDataDisplay.scrollHeight;
    
        // Update status to connected
        displayConnected();
    };
    
    // Handle errors
    socket.onerror = function(event) {
        displayDisconnected();
    };
    
    // Handle close events
    socket.onclose = function(event) {
        displayDisconnected();
    };
    
    // Periodically check connection status
    setInterval(checkConnection, 1000); // Check every 1 second
    
    // jQuery WebSocket handling for COM port
    $(document).ready(function () {
        const ws = new WebSocket('ws://localhost:8000/ws/comport/');
    
        ws.onmessage = function(event) {
            const data = JSON.parse(event.data);
            
            if (data.message) {
                lastMessageTime = Date.now(); // Reset timer when data is received
    
                // Match "+" pattern
                const plusChannels = data.message.match(/[A-K]\+[^\+A-K]*/g);
                if (plusChannels) {
                    plusChannels.forEach(channel => {
                        const channelId = channel.charAt(0);
                        const channelData = channel.charAt(1) + channel.substr(2); 
                        $(`#probe-${channelId}`).val(channelData);
                    });
                }
    
                // Match "-" pattern
                const minusChannels = data.message.match(/[A-K]\-[^\-A-K]*/g);
                if (minusChannels) {
                    minusChannels.forEach(channel => {
                        const channelId = channel.charAt(0);
                        const channelData = channel.charAt(1) + channel.substr(2); 
                        $(`#probe-${channelId}`).val(channelData);
                    });
                }
            }
        };
    });
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    document.addEventListener("DOMContentLoaded", function () {
        const inputFields = [
            "password_punch",
            
        ];
    
        const switchInput = document.getElementById("toggle-switch");
        let isPadEnabled = switchInput.checked;
    
        const numberPad = document.createElement("div");
        numberPad.id = "numberPad";
        numberPad.className = "num-pad";
        numberPad.style.display = "none";
    
        let isAlphabetMode = false;
        let alphabetKeys = {
            "abc": ["a", "b", "C"],
            "def": ["d", "e", "f"],
            "ghi": ["g", "h", "i"],
            "jkl": ["j", "k", "l"],
            "mno": ["m", "n", "o"],
            "pqrs": ["p", "q", "r", "s"],
            "tuv": ["t", "u", "v"],
            "wxyz": ["w", "x", "y", "z"]
        };
        let keyPressCount = {};
        let lastKeyPressed = null;
        let keyPressTimeout = null;
        let activeInput = null;
    
        const toggleButton = document.createElement("button");
        toggleButton.textContent = "ALP";
        toggleButton.className = "num-btn";
        toggleButton.addEventListener("mousedown", function (e) {
            e.preventDefault();
            toggleMode();
        });
    
        let buttons = [];
        createNumberPad();
        document.body.appendChild(numberPad);
    
        switchInput.addEventListener("change", function () {
            isPadEnabled = this.checked;
            if (!isPadEnabled) {
                numberPad.style.display = "none";
            }
        });
    
        // Apply to all input fields listed
        inputFields.forEach((id) => {
            const field = document.getElementById(id);
            if (field) {
                field.addEventListener("focus", function () {
                    activateKeypad(this);
                });
            }
        });
    
        function activateKeypad(inputElement) {
            if (!isPadEnabled) return;
    
            activeInput = inputElement;
            numberPad.style.display = "block";
            positionNumberPad(activeInput, numberPad);
    
            const isNumberOnly = inputElement.classList.contains("number-only");
            numberPad.innerHTML = "";
    
            if (isNumberOnly) {
                isAlphabetMode = false;
                createNumberPad();
            } else {
                numberPad.appendChild(toggleButton);
                numberPad.appendChild(document.createElement("br"));
                if (isAlphabetMode) {
                    createAlphabetPad();
                } else {
                    createNumberPad();
                }
            }
        }
    
        function toggleMode() {
            isAlphabetMode = !isAlphabetMode;
            toggleButton.textContent = isAlphabetMode ? "NUM" : "ALP";
            keyPressCount = {};
            lastKeyPressed = null;
            numberPad.innerHTML = "";
            numberPad.appendChild(toggleButton);
            numberPad.appendChild(document.createElement("br"));
    
            if (isAlphabetMode) {
                createAlphabetPad();
            } else {
                createNumberPad();
            }
        }
    
        function createNumberPad() {
            buttons = [];
            for (let i = 1; i <= 9; i++) {
                buttons.push(createButton(i));
                if (i % 3 === 0) numberPad.appendChild(document.createElement("br"));
            }
            buttons.push(createButton("_"));
            buttons.push(createButton(0));
            buttons.push(createButton("."));
            numberPad.appendChild(document.createElement("br"));
            buttons.push(createButton("C", clearLastCharacter));
            buttons.push(createButton("OK", hideNumberPad));
        }
    
        function createAlphabetPad() {
            buttons = [];
            for (let key in alphabetKeys) {
                buttons.push(createButton(key, function () {
                    handleAlphabetClick(key);
                }));
                if (buttons.length % 3 === 0) numberPad.appendChild(document.createElement("br"));
            }
    
            const symbolKey = "@+-*/%";
            buttons.push(createButton(symbolKey, function () {
                handleSymbolClick(symbolKey);
            }));
    
            numberPad.appendChild(document.createElement("br"));
            buttons.push(createButton("TAB", addSpace));
            buttons.push(createButton("C", clearLastCharacter));
            buttons.push(createButton("OK", hideNumberPad));
        }
    
        function createButton(value, callback) {
            const button = document.createElement("button");
            button.textContent = value;
            button.className = "num-btn";
            if (value === "@+-*/%") {
                button.style.fontSize = "2vw";
            }
    
            button.addEventListener("mousedown", function (e) {
                e.preventDefault(); // Prevent input blur
                (callback || function () {
                    handleButtonClick(value);
                })();
            });
    
            numberPad.appendChild(button);
            return button;
        }
    
        function handleButtonClick(value) {
            if (activeInput) {
                activeInput.value += value;
            }
        }
    
        function handleAlphabetClick(key) {
            if (!alphabetKeys[key] || !activeInput) return;
    
            if (lastKeyPressed !== key) {
                activeInput.value += alphabetKeys[key][0];
                keyPressCount[key] = 0;
            } else {
                keyPressCount[key] = (keyPressCount[key] + 1) % alphabetKeys[key].length;
                activeInput.value = activeInput.value.slice(0, -1) + alphabetKeys[key][keyPressCount[key]];
            }
    
            lastKeyPressed = key;
            clearTimeout(keyPressTimeout);
            keyPressTimeout = setTimeout(() => {
                lastKeyPressed = null;
            }, 1000);
        }
    
        function handleSymbolClick(symbols) {
            if (!activeInput) return;
    
            if (lastKeyPressed !== symbols) {
                activeInput.value += symbols[0];
                keyPressCount[symbols] = 0;
            } else {
                keyPressCount[symbols] = (keyPressCount[symbols] + 1) % symbols.length;
                activeInput.value = activeInput.value.slice(0, -1) + symbols[keyPressCount[symbols]];
            }
    
            lastKeyPressed = symbols;
            clearTimeout(keyPressTimeout);
            keyPressTimeout = setTimeout(() => {
                lastKeyPressed = null;
            }, 1000);
        }
    
        function addSpace() {
            if (activeInput) {
                activeInput.value += " ";
            }
        }
    
        function clearLastCharacter() {
            if (activeInput && activeInput.value.length > 0) {
                activeInput.value = activeInput.value.slice(0, -1);
            }
        }
    
        document.addEventListener("keydown", function (event) {
            if (event.key === "Enter" && numberPad.style.display === "block") {
                hideNumberPad();
            }
        });
    
        function hideNumberPad() {
            numberPad.style.display = "none";
        }
    
        function positionNumberPad(input, pad) {
            const rect = input.getBoundingClientRect();
            const padWidth = pad.offsetWidth || 220;
            const padHeight = pad.offsetHeight || 300;
            const padding = 10;
    
            let top = rect.bottom + window.scrollY + padding;
            let left = rect.left + window.scrollX;
    
            if (left + padWidth > window.innerWidth) {
                left = rect.right - padWidth + window.scrollX;
            }
    
            if (top + padHeight > window.innerHeight + window.scrollY) {
                top = rect.top + window.scrollY - padHeight - padding;
            }
    
            pad.style.position = "absolute";
            pad.style.left = `${left}px`;
            pad.style.top = `${top}px`;
            pad.style.display = "block";
        }
    });
    
    
    
    
    
    
    
    
    
    
    let overwriteButtons = [
        document.getElementById("overwrite_cancel_button"),
        document.getElementById("overwrite_ok_button")
    ];
    let overwriteIndex = 0;
    
    function updateOverwriteFocus() {
        overwriteButtons.forEach((btn, idx) => {
            if (idx === overwriteIndex) {
                btn.focus(); // set focus for accessibility
                btn.style.outline = "3px solid yellow"; // visual cue
            } else {
                btn.style.outline = "none";
            }
        });
    }
    
    
    
    let mode = "ALPHA"; // or "ALPHA"
    let lastKey = null;
    let lastPressTime = 0;
    let cycleIndex = 0;
    const cycleTimeout = 1000;
    let capsLock = false;
    
    
    
    
    // Overwrite popup buttons
    let currentButtonIndex = 0;
    const buttonList = [
      document.getElementById("overwrite_cancel_button"),
      document.getElementById("overwrite_ok_button")
    ];
    
    
    updateButtonFocus(buttonList, currentButtonIndex);
    
    
    // Credentials inputs + button
    let credentialFocusIndex = 0;
    const credentialElements = [
    //   document.getElementById("userid_punch"),
      document.getElementById("password_punch"),
      document.getElementById("punch_login")
    ];
    
    updateCredentialFocus(credentialFocusIndex);  // Focus userid_punch
    
    
    
    function updateButtonFocus(buttons, index) {
      buttons.forEach((btn, i) => {
        if (i === index) {
          btn.focus();
          btn.style.outline = "3px solid yellow";
        } else {
          btn.style.outline = "none";
        }
      });
    }
    
    function updateCredentialFocus(index) {
      credentialElements.forEach((el, i) => {
        if (i === index) {
          el.focus();
          el.style.outline = "3px solid yellow";  // Apply to both input and button
        } else {
          el.style.outline = "none";  // Remove from both input and button
        }
      });
    }
    
    function backspaceInput() {
        const focusedElement = credentialElements[credentialFocusIndex];
        if (focusedElement && focusedElement.tagName === "INPUT") {
            focusedElement.value = focusedElement.value.slice(0, -1);
        }
    }
    
    
    
    
    
    
    const keyboardSocket = new WebSocket("ws://" + window.location.host + "/ws/keypad/");
    
    const alpha_map = {
      "1": "1.,",
      "2": "abc", "3": "def", "4": "ghi", "5": "jkl",
      "6": "mno", "7": "pqrs", "8": "tuv", "9": "wxyz",
      "0": "0+-*#"
    };
    
    let reportModeActive = false;
    let reportButtonList = [];
    let reportButtonIndex = 0;
    
    function updateReportButtonFocus() {
      reportButtonList.forEach((btn, idx) => {
        if (idx === reportButtonIndex) {
          btn.focus();
          btn.classList.add("focused-report-button");
        } else {
          btn.blur();
          btn.classList.remove("focused-report-button");
        }
      });
    }
    
    keyboardSocket.onmessage = function(event) {
      const data = JSON.parse(event.data);
      const key = data.key;
    
      const overwriteVisible = document.getElementById("punch_overwrite").style.display === "block";
      const credentialsVisible = document.getElementById("punch_overwrite_credentials")?.style.display === "block";
    
      if (overwriteVisible && !credentialsVisible) {
        // Navigate popup buttons LFT/RGT
        if (key === "LFT") {
          currentButtonIndex = (currentButtonIndex - 1 + buttonList.length) % buttonList.length;
          updateButtonFocus(buttonList, currentButtonIndex);
        } else if (key === "RGT") {
          currentButtonIndex = (currentButtonIndex + 1) % buttonList.length;
          updateButtonFocus(buttonList, currentButtonIndex);
        } else if (key === "ENT") {
          buttonList[currentButtonIndex].click();
        }
        return;
      }
    
      if (credentialsVisible) {
        const focusedElement = credentialElements[credentialFocusIndex];
        const now = Date.now();
    
        if (key === "UP") {
          credentialFocusIndex = (credentialFocusIndex - 1 + credentialElements.length) % credentialElements.length;
          updateCredentialFocus(credentialFocusIndex);
        } else if (key === "DWN") {
          credentialFocusIndex = (credentialFocusIndex + 1) % credentialElements.length;
          updateCredentialFocus(credentialFocusIndex);
        } else if (key === "ENT") {
          if (focusedElement.tagName === "BUTTON") {
            focusedElement.click();
          } else {
            focusedElement.dispatchEvent(new KeyboardEvent('keydown', { key: 'Enter', bubbles: true }));
          }
        }
        else if (key === "F10") {
            backspaceInput();
        }
       else if (key === "ALP/NUM") {
          mode = mode === "NUM" ? "ALPHA" : "NUM";
          lastKey = null;
          cycleIndex = 0;
          console.log(`[MODE SWITCH] Mode changed to ${mode}`);
        } else if (focusedElement.tagName === "INPUT") {
            if (["LFT", "RGT", "UP", "DWN", "TAB", "START/STOP", "C1", "C2", "C3", "C4", "C5", "C6", "V Key", "F1", "F2", "F3", "F6", "F9", "F10", "F12"].includes(key)) {
                return;
            }
            if (mode === "ALPHA" && alpha_map[key]) {
                if (key === lastKey && (now - lastPressTime) < cycleTimeout) {
                    cycleIndex = (cycleIndex + 1) % alpha_map[key].length;
                    let charToReplace = alpha_map[key][cycleIndex];
                    if (capsLock) charToReplace = charToReplace.toUpperCase();
                    focusedElement.value = focusedElement.value.slice(0, -1) + charToReplace;
                } else {
                    cycleIndex = 0;
                    let charToAdd = alpha_map[key][cycleIndex];
                    if (capsLock) charToAdd = charToAdd.toUpperCase();
                    focusedElement.value += charToAdd;
                }
                lastKey = key;
                lastPressTime = Date.now();
            } 
        }
        return;
      }
    
      // ðŸŸ¨ Handle report mode navigation
      if (reportModeActive) {
        if (key === "LFT") {
          reportButtonIndex = (reportButtonIndex - 1 + reportButtonList.length) % reportButtonList.length;
          updateReportButtonFocus();
          return;
        } else if (key === "RGT") {
          reportButtonIndex = (reportButtonIndex + 1) % reportButtonList.length;
          updateReportButtonFocus();
          return;
        } else if (key === "ENT") {
          reportButtonList[reportButtonIndex].click();
          reportModeActive = false; // exit report mode after click
          return;
        }
      }
    
      // ðŸ”µ Default function key handling
      switch (key) {
        case "F1":
          document.getElementById("master_btn").click();
          break;
        case "F2":
          document.getElementById("model_btn").click();
          break;
        case "F3":
          document.getElementById("live_spc_btn").click();
          break;
        case "F12":
          document.getElementById("menu_btn").click();
          break;
        case "F9":
          document.getElementById("exit_btn").click();
          break;
        case "START/STOP":
            if (isStart) {
            startAction();
            } else {
            stopAction();
            }
            isStart = !isStart; // ðŸ” Toggle start/stop state
            break;
        case "F6":
          document.getElementById("report_btn_main").click();
    
          // Setup for report button navigation
          const spcBtn = document.getElementById("spc_btn");
          const reportBtn = document.getElementById("report_btn");
    
          if (spcBtn && reportBtn) {
            reportButtonList = [spcBtn, reportBtn];
            reportButtonIndex = 0;
            reportModeActive = true;
            updateReportButtonFocus();
          }
          break;
        case "ENT":
          const activeElement = document.activeElement;
          if (activeElement && activeElement.tagName === 'INPUT') {
            const enterEvent = new KeyboardEvent('keydown', {
              key: 'Enter',
              bubbles: true
            });
            activeElement.dispatchEvent(enterEvent);
          }
    
          if (isNotificationOpen) {
        if (key === "ENT") {
            document.getElementById("notificationOkBtn").click();
        }
        return; // block all other key actions while notification is shown
    }
    
          break;
        default:
          console.log("Unhandled key:", key);
      }
    };
    
    
    
    
    
    
    
    
    
    
    
    
    
    </script>
        
        
    </body>
    </html>